<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>1.3.1. The LIBLAMMPS Fortran Module &mdash; LAMMPS documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/tabs.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/lammps.css" type="text/css" />
    <link rel="shortcut icon" href="_static/lammps.ico"/>
    <link rel="canonical" href="https://docs.lammps.org/Fortran.html" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script async="async" src="_static/mathjax/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="1.4.1. Using the C++ API directly" href="Cplusplus.html" />
    <link rel="prev" title="1.1.10. Extending the C API" href="Library_add.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="Manual.html">
            <img src="_static/lammps-logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="lammps_version">Version: <b>8 Feb 2023</b></div>
              <div class="lammps_release">git info: 8Feb2023</div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Install.html">2. Install LAMMPS</a></li>
<li class="toctree-l1"><a class="reference internal" href="Build.html">3. Build LAMMPS</a></li>
<li class="toctree-l1"><a class="reference internal" href="Run_head.html">4. Run LAMMPS</a></li>
<li class="toctree-l1"><a class="reference internal" href="Commands.html">5. Commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="Packages.html">6. Optional packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="Speed.html">7. Accelerate performance</a></li>
<li class="toctree-l1"><a class="reference internal" href="Howto.html">8. Howto discussions</a></li>
<li class="toctree-l1"><a class="reference internal" href="Examples.html">9. Example scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tools.html">10. Auxiliary tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="Errors.html">11. Errors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Programmer Guide</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="Library.html">1. LAMMPS Library Interfaces</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Library.html#lammps-c-library-api">1.1. LAMMPS C Library API</a></li>
<li class="toctree-l2"><a class="reference internal" href="Library.html#lammps-python-apis">1.2. LAMMPS Python APIs</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="Library.html#lammps-fortran-api">1.3. LAMMPS Fortran API</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">1.3.1. The <code class="xref f f-mod docutils literal notranslate"><span class="pre">LIBLAMMPS</span></code> Fortran Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#creating-or-deleting-a-lammps-object">1.3.2. Creating or deleting a LAMMPS object</a></li>
<li class="toctree-l3"><a class="reference internal" href="#executing-lammps-commands">1.3.3. Executing LAMMPS commands</a></li>
<li class="toctree-l3"><a class="reference internal" href="#accessing-system-properties">1.3.4. Accessing system properties</a></li>
<li class="toctree-l3"><a class="reference internal" href="#f/LIBLAMMPS">1.3.5. The <code class="xref f f-mod docutils literal notranslate"><span class="pre">LIBLAMMPS</span></code> module API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Library.html#lammps-cplusplus-api">1.4. LAMMPS C++ API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Python_head.html">2. Use Python with LAMMPS</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modify.html">3. Modifying &amp; extending LAMMPS</a></li>
<li class="toctree-l1"><a class="reference internal" href="Developer.html">4. Information for Developers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Command Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="commands_list.html">Commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="fixes.html">Fixes</a></li>
<li class="toctree-l1"><a class="reference internal" href="computes.html">Computes</a></li>
<li class="toctree-l1"><a class="reference internal" href="pairs.html">Pair Styles</a></li>
<li class="toctree-l1"><a class="reference internal" href="bonds.html">Bond Styles</a></li>
<li class="toctree-l1"><a class="reference internal" href="angles.html">Angle Styles</a></li>
<li class="toctree-l1"><a class="reference internal" href="dihedrals.html">Dihedral Styles</a></li>
<li class="toctree-l1"><a class="reference internal" href="impropers.html">Improper Styles</a></li>
<li class="toctree-l1"><a class="reference internal" href="dumps.html">Dump Styles</a></li>
<li class="toctree-l1"><a class="reference internal" href="fix_modify_atc_commands.html">fix_modify AtC commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="Bibliography.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="Manual.html">LAMMPS</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="Manual.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="Library.html"><span class="section-number">1. </span>LAMMPS Library Interfaces</a></li>
      <li class="breadcrumb-item active"><span class="section-number">1.3.1. </span>The <code class="xref f f-mod docutils literal notranslate"><span class="pre">LIBLAMMPS</span></code> Fortran Module</li>
      <li class="wy-breadcrumbs-aside">
          <a href="https://www.lammps.org"><img src="_static/lammps-logo.png" width="64" height="16" alt="LAMMPS Homepage"></a> | <a href="Commands_all.html">Commands</a>
      </li>
  </ul><div class="rst-breadcrumbs-buttons" role="navigation" aria-label="Sequential page navigation">
        <a href="Library_add.html" class="btn btn-neutral float-left" title="1.1.10. Extending the C API" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Cplusplus.html" class="btn btn-neutral float-right" title="1.4.1. Using the C++ API directly" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
  </div>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p><span class="math notranslate nohighlight">\(\renewcommand{\AA}{\text{Å}}\)</span></p>
<section id="the-liblammps-fortran-module">
<h1><span class="section-number">1.3.1. </span>The <a class="reference internal" href="#f/LIBLAMMPS" title="f/LIBLAMMPS"><code class="xref f f-mod docutils literal notranslate"><span class="pre">LIBLAMMPS</span></code></a> Fortran Module<a class="headerlink" href="#the-liblammps-fortran-module" title="Permalink to this heading">¶</a></h1>
<p>The <a class="reference internal" href="#f/LIBLAMMPS" title="f/LIBLAMMPS"><code class="xref f f-mod docutils literal notranslate"><span class="pre">LIBLAMMPS</span></code></a> module provides an interface to call LAMMPS from
Fortran.  It is based on the LAMMPS C library interface and requires a
fully Fortran 2003-compatible compiler to be compiled.  It is designed
to be self-contained and not require any support functions written in C,
C++, or Fortran other than those in the C library interface and the
LAMMPS Fortran module itself.</p>
<p>While C libraries have a defined binary interface (ABI) and can thus be
used from multiple compiler versions from different vendors as long as
they are compatible with the hosting operating system, the same is not
true for Fortran programs.  Thus, the LAMMPS Fortran module needs to be
compiled alongside the code using it from the source code in
<code class="docutils literal notranslate"><span class="pre">fortran/lammps.f90</span></code> <em>and</em> with the same compiler used to build the
rest of the Fortran code that interfaces to LAMMPS.  When linking, you
also need to <a class="reference internal" href="Build_link.html"><span class="doc">link to the LAMMPS library</span></a>.  A typical
command line for a simple program using the Fortran interface would be:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>mpifort<span class="w"> </span>-o<span class="w"> </span>testlib.x<span class="w"> </span>lammps.f90<span class="w"> </span>testlib.f90<span class="w"> </span>-L.<span class="w"> </span>-llammps
</pre></div>
</div>
<p>Please note that the MPI compiler wrapper is only required when the
calling the library <em>from</em> an MPI-parallelized program.  Otherwise,
using the plain Fortran compiler (gfortran, ifort, flang, etc.) will
suffice, since there are no direct references to MPI library features,
definitions and subroutine calls; MPI communicators are referred to by
their integer index representation as required by the Fortran MPI
interface.  It may be necessary to link to additional libraries,
depending on how LAMMPS was configured and whether the LAMMPS library
<a class="reference internal" href="Build_link.html"><span class="doc">was compiled as a static or dynamic library</span></a>.</p>
<p>If the LAMMPS library itself has been compiled with MPI support, the
resulting executable will be able to run LAMMPS in parallel with
<code class="docutils literal notranslate"><span class="pre">mpirun</span></code>, <code class="docutils literal notranslate"><span class="pre">mpiexec</span></code>, or equivalent.  This may be either on the
“world” communicator or a sub-communicator created by the calling
Fortran code.  If, on the other hand, the LAMMPS library has been
compiled <strong>without</strong> MPI support, each LAMMPS instance will run
independently using just one processor.</p>
<p>Please also note that the order of the source files matters: the
<code class="docutils literal notranslate"><span class="pre">lammps.f90</span></code> file needs to be compiled first, since it provides the
<a class="reference internal" href="#f/LIBLAMMPS" title="f/LIBLAMMPS"><code class="xref f f-mod docutils literal notranslate"><span class="pre">LIBLAMMPS</span></code></a> module that would need to be imported by the calling
Fortran code in order to uses the Fortran interface.
A working example can be found together with equivalent examples in C and
C++ in the <code class="docutils literal notranslate"><span class="pre">examples/COUPLE/simple</span></code> folder of the LAMMPS distribution.</p>
<div class="note admonition">
<p class="admonition-title">Fortran compiler compatibility</p>
<p>A fully Fortran 2003 compatible Fortran compiler is required.
This means that currently only GNU Fortran 9 and later are
compatible and thus the default compilers of Red Hat or CentOS 7
and Ubuntu 18.04 LTS and not compatible.  Either newer compilers
need to be installed or the Linux updated.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 8Feb2023.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A contributed Fortran interface is available in the
<code class="docutils literal notranslate"><span class="pre">examples/COUPLE/fortran2</span></code> folder.  However, since the completion
of the <a class="reference internal" href="#f/LIBLAMMPS" title="f/LIBLAMMPS"><code class="xref f f-mod docutils literal notranslate"><span class="pre">LIBLAMMPS</span></code></a> module, this interface is now deprecated,
no longer actively maintained and will likely be removed in the
future.  Please see the <code class="docutils literal notranslate"><span class="pre">README</span></code> file in that folder for more
information about it and how to contact its author and maintainer.</p>
</div>
</section>
<hr class="docutils" />
<section id="creating-or-deleting-a-lammps-object">
<h1><span class="section-number">1.3.2. </span>Creating or deleting a LAMMPS object<a class="headerlink" href="#creating-or-deleting-a-lammps-object" title="Permalink to this heading">¶</a></h1>
<p>With the Fortran interface, the creation of a <a class="reference internal" href="Classes_lammps.html#_CPPv4N9LAMMPS_NS6LAMMPSE" title="LAMMPS_NS::LAMMPS"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">LAMMPS</span></code></a> instance is included in the constructor for
creating the <a class="reference internal" href="#f/_/lammps" title="f/_/lammps"><code class="xref f f-func docutils literal notranslate"><span class="pre">lammps()</span></code></a> derived type.  To import the definition of
that type and its type-bound procedures, you need to add a <code class="docutils literal notranslate"><span class="pre">USE</span> <span class="pre">LIBLAMMPS</span></code>
statement.  Internally, it will call either
<a class="reference internal" href="Library_create.html#_CPPv419lammps_open_fortraniPPci" title="lammps_open_fortran"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_open_fortran()</span></code></a> or <a class="reference internal" href="Library_create.html#_CPPv418lammps_open_no_mpiiPPcPPv" title="lammps_open_no_mpi"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_open_no_mpi()</span></code></a> from
the C library API to create the class instance.  All arguments are
optional and <a class="reference internal" href="Library_create.html#_CPPv415lammps_mpi_initv" title="lammps_mpi_init"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_mpi_init()</span></code></a> will be called automatically
if it is needed.  Similarly, a possible call to
<a class="reference internal" href="Library_create.html#_CPPv419lammps_mpi_finalizev" title="lammps_mpi_finalize"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_mpi_finalize()</span></code></a> is integrated into the <a class="reference internal" href="#f/_/close" title="f/_/close"><code class="xref f f-func docutils literal notranslate"><span class="pre">close()</span></code></a>
function and triggered with the optional logical argument set to
<code class="docutils literal notranslate"><span class="pre">.TRUE.</span></code>. Here is a simple example:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">PROGRAM </span><span class="n">testlib</span>
<span class="w">  </span><span class="k">USE </span><span class="n">LIBLAMMPS</span><span class="w">                 </span><span class="c">! include the LAMMPS library interface</span>
<span class="w">  </span><span class="k">IMPLICIT NONE</span>
<span class="k">  TYPE</span><span class="p">(</span><span class="n">lammps</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">lmp</span><span class="w">           </span><span class="c">! derived type to hold LAMMPS instance</span>
<span class="w">  </span><span class="kt">CHARACTER</span><span class="p">(</span><span class="nb">LEN</span><span class="o">=</span><span class="mi">12</span><span class="p">),</span><span class="w"> </span><span class="k">PARAMETER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">args</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">      </span><span class="p">[</span><span class="w"> </span><span class="kt">CHARACTER</span><span class="p">(</span><span class="nb">LEN</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="s1">&#39;liblammps&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;-log&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;none&#39;</span><span class="w"> </span><span class="p">]</span>

<span class="w">  </span><span class="c">! create a LAMMPS instance (and initialize MPI)</span>
<span class="w">  </span><span class="n">lmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lammps</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="w">  </span><span class="c">! get and print numerical version code</span>
<span class="w">  </span><span class="k">PRINT</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;LAMMPS Version: &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">version</span><span class="p">()</span>
<span class="w">  </span><span class="c">! delete LAMMPS instance (and shutdown MPI)</span>
<span class="w">  </span><span class="k">CALL </span><span class="n">lmp</span><span class="p">%</span><span class="k">close</span><span class="p">(.</span><span class="n">TRUE</span><span class="p">.)</span>
<span class="k">END PROGRAM </span><span class="n">testlib</span>
</pre></div>
</div>
<p>It is also possible to pass command line flags from Fortran to C/C++ and
thus make the resulting executable behave similarly to the standalone
executable (it will ignore the <cite>-in/-i</cite> flag, though).  This allows
using the command line to configure accelerator and suffix settings,
configure screen and logfile output, or to set index style variables
from the command line and more.  Here is a correspondingly adapted
version of the previous example:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">PROGRAM </span><span class="n">testlib2</span>
<span class="w">  </span><span class="k">USE </span><span class="n">LIBLAMMPS</span><span class="w">                 </span><span class="c">! include the LAMMPS library interface</span>
<span class="w">  </span><span class="k">IMPLICIT NONE</span>
<span class="k">  TYPE</span><span class="p">(</span><span class="n">lammps</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">lmp</span><span class="w">           </span><span class="c">! derived type to hold LAMMPS instance</span>
<span class="w">  </span><span class="kt">CHARACTER</span><span class="p">(</span><span class="nb">LEN</span><span class="o">=</span><span class="mi">128</span><span class="p">),</span><span class="w"> </span><span class="k">ALLOCATABLE</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">command_args</span><span class="p">(:)</span>
<span class="w">  </span><span class="kt">INTEGER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">argc</span>

<span class="w">  </span><span class="c">! copy command line flags to `command_args()`</span>
<span class="w">  </span><span class="n">argc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">COMMAND_ARGUMENT_COUNT</span><span class="p">()</span>
<span class="w">  </span><span class="k">ALLOCATE</span><span class="p">(</span><span class="n">command_args</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="n">argc</span><span class="p">))</span>
<span class="w">  </span><span class="k">DO </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">argc</span>
<span class="w">    </span><span class="k">CALL </span><span class="nb">GET_COMMAND_ARGUMENT</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">command_args</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="w">  </span><span class="k">END DO</span>

<span class="w">  </span><span class="c">! create a LAMMPS instance (and initialize MPI)</span>
<span class="w">  </span><span class="n">lmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lammps</span><span class="p">(</span><span class="n">command_args</span><span class="p">)</span>
<span class="w">  </span><span class="c">! get and print numerical version code</span>
<span class="w">  </span><span class="k">PRINT</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Program name:   &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">command_args</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">  </span><span class="k">PRINT</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;LAMMPS Version: &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">version</span><span class="p">()</span>
<span class="w">  </span><span class="c">! delete LAMMPS instance (and shuts down MPI)</span>
<span class="w">  </span><span class="k">CALL </span><span class="n">lmp</span><span class="p">%</span><span class="k">close</span><span class="p">(.</span><span class="n">TRUE</span><span class="p">.)</span>
<span class="w">  </span><span class="k">DEALLOCATE</span><span class="p">(</span><span class="n">command_args</span><span class="p">)</span>
<span class="k">END PROGRAM </span><span class="n">testlib2</span>
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="executing-lammps-commands">
<h1><span class="section-number">1.3.3. </span>Executing LAMMPS commands<a class="headerlink" href="#executing-lammps-commands" title="Permalink to this heading">¶</a></h1>
<p>Once a LAMMPS instance is created, it is possible to “drive” the LAMMPS
simulation by telling LAMMPS to read commands from a file or to pass
individual or multiple commands from strings or lists of strings.  This
is done similarly to how it is implemented in the <a class="reference internal" href="Library_execute.html"><span class="doc">C library
interface</span></a>. Before handing off the calls to the
C library interface, the corresponding Fortran versions of the calls
(<a class="reference internal" href="#f/_/file" title="f/_/file"><code class="xref f f-func docutils literal notranslate"><span class="pre">file()</span></code></a>, <a class="reference internal" href="#f/_/command" title="f/_/command"><code class="xref f f-func docutils literal notranslate"><span class="pre">command()</span></code></a>, <a class="reference internal" href="#f/_/commands_list" title="f/_/commands_list"><code class="xref f f-func docutils literal notranslate"><span class="pre">commands_list()</span></code></a>, and
<a class="reference internal" href="#f/_/commands_string" title="f/_/commands_string"><code class="xref f f-func docutils literal notranslate"><span class="pre">commands_string()</span></code></a>) have to make copies of the strings passed as
arguments so that they can be modified to be compatible with the
requirements of strings in C without affecting the original strings.
Those copies are automatically deleted after the functions return.
Below is a small demonstration of the uses of the different functions.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">PROGRAM </span><span class="n">testcmd</span>
<span class="w">  </span><span class="k">USE </span><span class="n">LIBLAMMPS</span>
<span class="w">  </span><span class="k">TYPE</span><span class="p">(</span><span class="n">lammps</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">lmp</span>
<span class="w">  </span><span class="kt">CHARACTER</span><span class="p">(</span><span class="nb">LEN</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">cmds</span>
<span class="w">  </span><span class="kt">CHARACTER</span><span class="p">(</span><span class="nb">LEN</span><span class="o">=</span><span class="mi">40</span><span class="p">),</span><span class="w"> </span><span class="k">ALLOCATABLE</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">cmdlist</span><span class="p">(:)</span>
<span class="w">  </span><span class="kt">CHARACTER</span><span class="p">(</span><span class="nb">LEN</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">trimmed</span>
<span class="w">  </span><span class="kt">INTEGER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">i</span>

<span class="w">  </span><span class="n">lmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lammps</span><span class="p">()</span>
<span class="w">  </span><span class="k">CALL </span><span class="n">lmp</span><span class="p">%</span><span class="k">file</span><span class="p">(</span><span class="s1">&#39;in.melt&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="k">CALL </span><span class="n">lmp</span><span class="p">%</span><span class="n">command</span><span class="p">(</span><span class="s1">&#39;variable zpos index 1.0&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="c">! define 10 groups of 10 atoms each</span>
<span class="w">  </span><span class="k">ALLOCATE</span><span class="p">(</span><span class="n">cmdlist</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="w">  </span><span class="k">DO </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span>
<span class="w">    </span><span class="k">WRITE</span><span class="p">(</span><span class="n">trimmed</span><span class="p">,</span><span class="s1">&#39;(I10)&#39;</span><span class="p">)</span><span class="w"> </span><span class="mi">10</span><span class="o">*</span><span class="n">i</span>
<span class="w">    </span><span class="k">WRITE</span><span class="p">(</span><span class="n">cmdlist</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="s1">&#39;(A,I1,A,I10,A,A)&#39;</span><span class="p">)</span><span class="w">       </span><span class="p">&amp;</span>
<span class="w">        </span><span class="s1">&#39;group g&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39; id &#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;:&#39;</span><span class="p">,</span><span class="w"> </span><span class="nb">ADJUSTL</span><span class="p">(</span><span class="n">trimmed</span><span class="p">)</span>
<span class="w">  </span><span class="k">END DO</span>
<span class="k">  CALL </span><span class="n">lmp</span><span class="p">%</span><span class="n">commands_list</span><span class="p">(</span><span class="n">cmdlist</span><span class="p">)</span>
<span class="w">  </span><span class="c">! run multiple commands from multi-line string</span>
<span class="w">  </span><span class="n">cmds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;clear&#39;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">NEW_LINE</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w">                       </span><span class="p">&amp;</span>
<span class="w">      </span><span class="s1">&#39;region  box block 0 2 0 2 0 2&#39;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">NEW_LINE</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w">  </span><span class="p">&amp;</span>
<span class="w">      </span><span class="s1">&#39;create_box 1 box&#39;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb">NEW_LINE</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w">               </span><span class="p">&amp;</span>
<span class="w">      </span><span class="s1">&#39;create_atoms 1 single 1.0 1.0 ${zpos}&#39;</span>
<span class="w">  </span><span class="k">CALL </span><span class="n">lmp</span><span class="p">%</span><span class="n">commands_string</span><span class="p">(</span><span class="n">cmds</span><span class="p">)</span>
<span class="w">  </span><span class="k">CALL </span><span class="n">lmp</span><span class="p">%</span><span class="k">close</span><span class="p">(.</span><span class="n">TRUE</span><span class="p">.)</span>
<span class="k">END PROGRAM </span><span class="n">testcmd</span>
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="accessing-system-properties">
<h1><span class="section-number">1.3.4. </span>Accessing system properties<a class="headerlink" href="#accessing-system-properties" title="Permalink to this heading">¶</a></h1>
<p>The C library interface allows the <a class="reference internal" href="Library_properties.html"><span class="doc">extraction of different kinds
of information</span></a> about the active simulation
instance and also—in some cases—to apply modifications to it, and the
Fortran interface provides access to the same data using Fortran-style,
C-interoperable data types.  In some cases, the Fortran library interface makes
pointers to internal LAMMPS data structures accessible; when accessing them
through the library interfaces, special care is needed to avoid data corruption
and crashes.  Please see the documentation of the individual type-bound
procedures for details.</p>
<p>Below is an example demonstrating some of the possible uses.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">PROGRAM </span><span class="n">testprop</span>
<span class="w">  </span><span class="k">USE </span><span class="n">LIBLAMMPS</span>
<span class="w">  </span><span class="k">USE</span><span class="p">,</span><span class="w"> </span><span class="k">INTRINSIC</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="nb">ISO_C_BINDING</span><span class="p">,</span><span class="w"> </span><span class="k">ONLY</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">c_double</span><span class="p">,</span><span class="w"> </span><span class="kt">c_int64_t</span>
<span class="kt">  </span><span class="k">USE</span><span class="p">,</span><span class="w"> </span><span class="k">INTRINSIC</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">ISO_FORTRAN_ENV</span><span class="p">,</span><span class="w"> </span><span class="k">ONLY</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">OUTPUT_UNIT</span>
<span class="w">  </span><span class="k">TYPE</span><span class="p">(</span><span class="n">lammps</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">lmp</span>
<span class="w">  </span><span class="kt">INTEGER</span><span class="p">(</span><span class="nb">KIND</span><span class="o">=</span><span class="kt">c_int64_t</span><span class="p">),</span><span class="w"> </span><span class="k">POINTER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">natoms</span>
<span class="w">  </span><span class="kt">REAL</span><span class="p">(</span><span class="nb">KIND</span><span class="o">=</span><span class="kt">c_double</span><span class="p">),</span><span class="w"> </span><span class="k">POINTER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">dt</span>
<span class="w">  </span><span class="kt">INTEGER</span><span class="p">(</span><span class="nb">KIND</span><span class="o">=</span><span class="kt">c_int64_t</span><span class="p">),</span><span class="w"> </span><span class="k">POINTER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">ntimestep</span>
<span class="w">  </span><span class="kt">REAL</span><span class="p">(</span><span class="nb">KIND</span><span class="o">=</span><span class="kt">c_double</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">pe</span><span class="p">,</span><span class="w"> </span><span class="n">ke</span>

<span class="w">  </span><span class="n">lmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lammps</span><span class="p">()</span>
<span class="w">  </span><span class="k">CALL </span><span class="n">lmp</span><span class="p">%</span><span class="k">file</span><span class="p">(</span><span class="s1">&#39;in.sysinit&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="n">natoms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">extract_global</span><span class="p">(</span><span class="s1">&#39;natoms&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="k">WRITE</span><span class="p">(</span><span class="n">OUTPUT_UNIT</span><span class="p">,</span><span class="s1">&#39;(A,I0,A)&#39;</span><span class="p">)</span><span class="w"> </span><span class="s1">&#39;Running a simulation with &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">natoms</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39; atoms&#39;</span>
<span class="w">  </span><span class="k">WRITE</span><span class="p">(</span><span class="n">OUTPUT_UNIT</span><span class="p">,</span><span class="s1">&#39;(I0,A,I0,A,I0,A)&#39;</span><span class="p">)</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">extract_setting</span><span class="p">(</span><span class="s1">&#39;nlocal&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">      </span><span class="s1">&#39; local and &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">extract_setting</span><span class="p">(</span><span class="s1">&#39;nghost&#39;</span><span class="p">),</span><span class="w"> </span><span class="s1">&#39; ghost atoms. &#39;</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">      </span><span class="n">lmp</span><span class="p">%</span><span class="n">extract_setting</span><span class="p">(</span><span class="s1">&#39;ntypes&#39;</span><span class="p">),</span><span class="w"> </span><span class="s1">&#39; atom types&#39;</span>

<span class="w">  </span><span class="k">CALL </span><span class="n">lmp</span><span class="p">%</span><span class="n">command</span><span class="p">(</span><span class="s1">&#39;run 2 post no&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="n">dt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">extract_global</span><span class="p">(</span><span class="s1">&#39;dt&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="n">ntimestep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">extract_global</span><span class="p">(</span><span class="s1">&#39;ntimestep&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="k">WRITE</span><span class="p">(</span><span class="n">OUTPUT_UNIT</span><span class="p">,</span><span class="s1">&#39;(A,I0,A,F4.1,A)&#39;</span><span class="p">)</span><span class="w"> </span><span class="s1">&#39;At step: &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">ntimestep</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">      </span><span class="s1">&#39;  Changing timestep from&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">dt</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39; to 0.5&#39;</span>
<span class="w">  </span><span class="n">dt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5_c_double</span>
<span class="w">  </span><span class="k">CALL </span><span class="n">lmp</span><span class="p">%</span><span class="n">command</span><span class="p">(</span><span class="s1">&#39;run 2 post no&#39;</span><span class="p">)</span>

<span class="w">  </span><span class="k">WRITE</span><span class="p">(</span><span class="n">OUTPUT_UNIT</span><span class="p">,</span><span class="s1">&#39;(A,I0)&#39;</span><span class="p">)</span><span class="w"> </span><span class="s1">&#39;At step: &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">ntimestep</span>
<span class="w">  </span><span class="n">pe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">get_thermo</span><span class="p">(</span><span class="s1">&#39;pe&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="n">ke</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">get_thermo</span><span class="p">(</span><span class="s1">&#39;ke&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="k">PRINT</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;PE = &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">pe</span>
<span class="w">  </span><span class="k">PRINT</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;KE = &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">ke</span>

<span class="w">  </span><span class="k">CALL </span><span class="n">lmp</span><span class="p">%</span><span class="k">close</span><span class="p">(.</span><span class="n">TRUE</span><span class="p">.)</span>
<span class="k">END PROGRAM </span><span class="n">testprop</span>
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="f/LIBLAMMPS">
<span id="the-liblammps-module-api"></span><h1><span class="section-number">1.3.5. </span>The <a class="reference internal" href="#f/LIBLAMMPS" title="f/LIBLAMMPS"><code class="xref f f-mod docutils literal notranslate"><span class="pre">LIBLAMMPS</span></code></a> module API<a class="headerlink" href="#f/LIBLAMMPS" title="Permalink to this heading">¶</a></h1>
<p>Below are the detailed descriptions of definitions and interfaces
of the contents of the <a class="reference internal" href="#f/LIBLAMMPS" title="f/LIBLAMMPS"><code class="xref f f-mod docutils literal notranslate"><span class="pre">LIBLAMMPS</span></code></a> Fortran interface to LAMMPS.</p>
<dl>
<dt class="sig sig-object f" id="f/_/lammps">
<em class="property"><span class="pre">type</span>&#160; </em><span class="sig-name descname"><span class="pre">lammps</span></span><a class="headerlink" href="#f/_/lammps" title="Permalink to this definition">¶</a></dt>
<dd><p>Derived type that is the general class of the Fortran interface.
It holds a reference to the <a class="reference internal" href="Classes_lammps.html#_CPPv4N9LAMMPS_NS6LAMMPSE" title="LAMMPS_NS::LAMMPS"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">LAMMPS</span></code></a>
class instance to which any of the included calls are forwarded.</p>
<dl class="field-list simple">
<dt class="field-odd">Type fields<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">handle</span><em> [</em><em>c_ptr</em><em>]</em> :: reference to the LAMMPS class</p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">style</span><em> [</em><em>type(lammps_style)</em><em>]</em> :: derived type to access lammps style constants</p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">type</span><em> [</em><em>type(lammps_type)</em><em>]</em> :: derived type to access lammps type constants</p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">close</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/close" title="f/_/close"><code class="xref f f-subr docutils literal notranslate"><span class="pre">close()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">error</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/error" title="f/_/error"><code class="xref f f-subr docutils literal notranslate"><span class="pre">error()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">file</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/file" title="f/_/file"><code class="xref f f-subr docutils literal notranslate"><span class="pre">file()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">command</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/command" title="f/_/command"><code class="xref f f-subr docutils literal notranslate"><span class="pre">command()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">commands_list</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/commands_list" title="f/_/commands_list"><code class="xref f f-subr docutils literal notranslate"><span class="pre">commands_list()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">commands_string</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/commands_string" title="f/_/commands_string"><code class="xref f f-subr docutils literal notranslate"><span class="pre">commands_string()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">get_natoms</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/get_natoms" title="f/_/get_natoms"><code class="xref f f-func docutils literal notranslate"><span class="pre">get_natoms()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">get_thermo</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/get_thermo" title="f/_/get_thermo"><code class="xref f f-func docutils literal notranslate"><span class="pre">get_thermo()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">extract_box</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/extract_box" title="f/_/extract_box"><code class="xref f f-subr docutils literal notranslate"><span class="pre">extract_box()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">reset_box</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/reset_box" title="f/_/reset_box"><code class="xref f f-subr docutils literal notranslate"><span class="pre">reset_box()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">memory_usage</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/memory_usage" title="f/_/memory_usage"><code class="xref f f-subr docutils literal notranslate"><span class="pre">memory_usage()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">get_mpi_comm</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/get_mpi_comm" title="f/_/get_mpi_comm"><code class="xref f f-func docutils literal notranslate"><span class="pre">get_mpi_comm()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">extract_setting</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/extract_setting" title="f/_/extract_setting"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_setting()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">extract_global</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/extract_global" title="f/_/extract_global"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_global()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">extract_atom</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/extract_atom" title="f/_/extract_atom"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_atom()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">extract_compute</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/extract_compute" title="f/_/extract_compute"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_compute()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">extract_fix</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/extract_fix" title="f/_/extract_fix"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_fix()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">extract_variable</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/extract_variable" title="f/_/extract_variable"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_variable()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">set_variable</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/set_variable" title="f/_/set_variable"><code class="xref f f-subr docutils literal notranslate"><span class="pre">set_variable()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">gather_atoms</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/gather_atoms" title="f/_/gather_atoms"><code class="xref f f-subr docutils literal notranslate"><span class="pre">gather_atoms()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">gather_atoms_concat</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/gather_atoms_concat" title="f/_/gather_atoms_concat"><code class="xref f f-subr docutils literal notranslate"><span class="pre">gather_atoms_concat()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">gather_atoms_subset</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/gather_atoms_subset" title="f/_/gather_atoms_subset"><code class="xref f f-subr docutils literal notranslate"><span class="pre">gather_atoms_subset()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">scatter_atoms</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/scatter_atoms" title="f/_/scatter_atoms"><code class="xref f f-subr docutils literal notranslate"><span class="pre">scatter_atoms()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">scatter_atoms_subset</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/scatter_atoms_subset" title="f/_/scatter_atoms_subset"><code class="xref f f-subr docutils literal notranslate"><span class="pre">scatter_atoms_subset()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">gather_bonds</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/gather_bonds" title="f/_/gather_bonds"><code class="xref f f-subr docutils literal notranslate"><span class="pre">gather_bonds()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">gather_angles</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/gather_angles" title="f/_/gather_angles"><code class="xref f f-subr docutils literal notranslate"><span class="pre">gather_angles()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">gather_dihedrals</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/gather_dihedrals" title="f/_/gather_dihedrals"><code class="xref f f-subr docutils literal notranslate"><span class="pre">gather_dihedrals()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">gather_impropers</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/gather_impropers" title="f/_/gather_impropers"><code class="xref f f-subr docutils literal notranslate"><span class="pre">gather_impropers()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">gather</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/gather" title="f/_/gather"><code class="xref f f-subr docutils literal notranslate"><span class="pre">gather()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">gather_concat</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/gather_concat" title="f/_/gather_concat"><code class="xref f f-subr docutils literal notranslate"><span class="pre">gather_concat()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">gather_subset</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/gather_subset" title="f/_/gather_subset"><code class="xref f f-subr docutils literal notranslate"><span class="pre">gather_subset()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">scatter</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/scatter" title="f/_/scatter"><code class="xref f f-subr docutils literal notranslate"><span class="pre">scatter()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">scatter_subset</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/scatter_subset" title="f/_/scatter_subset"><code class="xref f f-subr docutils literal notranslate"><span class="pre">scatter_subset()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">create_atoms</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/create_atoms" title="f/_/create_atoms"><code class="xref f f-subr docutils literal notranslate"><span class="pre">create_atoms()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">find_pair_neighlist</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/find_pair_neighlist" title="f/_/find_pair_neighlist"><code class="xref f f-func docutils literal notranslate"><span class="pre">find_pair_neighlist()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">find_fix_neighlist</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/find_fix_neighlist" title="f/_/find_fix_neighlist"><code class="xref f f-func docutils literal notranslate"><span class="pre">find_fix_neighlist()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">find_compute_neighlist</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/find_compute_neighlist" title="f/_/find_compute_neighlist"><code class="xref f f-func docutils literal notranslate"><span class="pre">find_compute_neighlist()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">neighlist_num_elements</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/neighlist_num_elements" title="f/_/neighlist_num_elements"><code class="xref f f-func docutils literal notranslate"><span class="pre">neighlist_num_elements()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">neighlist_element_neighbors</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/neighlist_element_neighbors" title="f/_/neighlist_element_neighbors"><code class="xref f f-subr docutils literal notranslate"><span class="pre">neighlist_element_neighbors()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">version</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/version" title="f/_/version"><code class="xref f f-func docutils literal notranslate"><span class="pre">version()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">get_os_info</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/get_os_info" title="f/_/get_os_info"><code class="xref f f-subr docutils literal notranslate"><span class="pre">get_os_info()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">config_has_mpi_support</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/config_has_mpi_support" title="f/_/config_has_mpi_support"><code class="xref f f-func docutils literal notranslate"><span class="pre">config_has_mpi_support()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">config_has_gzip_support</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/config_has_gzip_support" title="f/_/config_has_gzip_support"><code class="xref f f-func docutils literal notranslate"><span class="pre">config_has_gzip_support()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">config_has_png_support</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/config_has_png_support" title="f/_/config_has_png_support"><code class="xref f f-func docutils literal notranslate"><span class="pre">config_has_png_support()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">config_has_jpeg_support</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/config_has_jpeg_support" title="f/_/config_has_jpeg_support"><code class="xref f f-func docutils literal notranslate"><span class="pre">config_has_jpeg_support()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">config_has_ffmpeg_support</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/config_has_ffmpeg_support" title="f/_/config_has_ffmpeg_support"><code class="xref f f-func docutils literal notranslate"><span class="pre">config_has_ffmpeg_support()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">config_has_exceptions</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/config_has_exceptions" title="f/_/config_has_exceptions"><code class="xref f f-func docutils literal notranslate"><span class="pre">config_has_exceptions()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">config_has_package</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/config_has_package" title="f/_/config_has_package"><code class="xref f f-func docutils literal notranslate"><span class="pre">config_has_package()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">config_package_count</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/config_package_count" title="f/_/config_package_count"><code class="xref f f-func docutils literal notranslate"><span class="pre">config_package_count()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">config_package_name</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/config_package_name" title="f/_/config_package_name"><code class="xref f f-func docutils literal notranslate"><span class="pre">config_package_name()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">installed_packages</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/installed_packages" title="f/_/installed_packages"><code class="xref f f-subr docutils literal notranslate"><span class="pre">installed_packages()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">config_accelerator</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/config_accelerator" title="f/_/config_accelerator"><code class="xref f f-func docutils literal notranslate"><span class="pre">config_accelerator()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">has_gpu_device</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/has_gpu_device" title="f/_/has_gpu_device"><code class="xref f f-func docutils literal notranslate"><span class="pre">has_gpu_device()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">get_gpu_device_info</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/get_gpu_device_info" title="f/_/get_gpu_device_info"><code class="xref f f-subr docutils literal notranslate"><span class="pre">get_gpu_device_info()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">has_style</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/has_style" title="f/_/has_style"><code class="xref f f-func docutils literal notranslate"><span class="pre">has_style()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">style_count</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/style_count" title="f/_/style_count"><code class="xref f f-func docutils literal notranslate"><span class="pre">style_count()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">style_name</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/style_name" title="f/_/style_name"><code class="xref f f-func docutils literal notranslate"><span class="pre">style_name()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">has_id</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/has_id" title="f/_/has_id"><code class="xref f f-func docutils literal notranslate"><span class="pre">has_id()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">id_count</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/id_count" title="f/_/id_count"><code class="xref f f-func docutils literal notranslate"><span class="pre">id_count()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">id_name</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/id_name" title="f/_/id_name"><code class="xref f f-subr docutils literal notranslate"><span class="pre">id_name()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">plugin_count</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/plugin_count" title="f/_/plugin_count"><code class="xref f f-func docutils literal notranslate"><span class="pre">plugin_count()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">plugin_name</span> :: <a class="reference internal" href="#f/_/plugin_name" title="f/_/plugin_name"><code class="xref f f-subr docutils literal notranslate"><span class="pre">plugin_name()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">encode_image_flags</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/encode_image_flags" title="f/_/encode_image_flags"><code class="xref f f-func docutils literal notranslate"><span class="pre">encode_image_flags()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">decode_image_flags</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/decode_image_flags" title="f/_/decode_image_flags"><code class="xref f f-subr docutils literal notranslate"><span class="pre">decode_image_flags()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">set_fix_external_callback</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/set_fix_external_callback" title="f/_/set_fix_external_callback"><code class="xref f f-subr docutils literal notranslate"><span class="pre">set_fix_external_callback()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">fix_external_get_force</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/fix_external_get_force" title="f/_/fix_external_get_force"><code class="xref f f-func docutils literal notranslate"><span class="pre">fix_external_get_force()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">fix_external_set_energy_global</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/fix_external_set_energy_global" title="f/_/fix_external_set_energy_global"><code class="xref f f-subr docutils literal notranslate"><span class="pre">fix_external_set_energy_global()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">fix_external_set_virial_global</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/fix_external_set_virial_global" title="f/_/fix_external_set_virial_global"><code class="xref f f-subr docutils literal notranslate"><span class="pre">fix_external_set_virial_global()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">fix_external_set_energy_peratom</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/fix_external_set_energy_peratom" title="f/_/fix_external_set_energy_peratom"><code class="xref f f-subr docutils literal notranslate"><span class="pre">fix_external_set_energy_peratom()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">fix_external_set_virial_peratom</span><em> [</em><em>subroutine</em><em>]</em> :: <code class="xref f f-subr docutils literal notranslate"><span class="pre">fix_external_set_virial_peratom()</span></code></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">fix_external_set_vector_length</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/fix_external_set_vector_length" title="f/_/fix_external_set_vector_length"><code class="xref f f-subr docutils literal notranslate"><span class="pre">fix_external_set_vector_length()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">fix_external_set_vector</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/fix_external_set_vector" title="f/_/fix_external_set_vector"><code class="xref f f-subr docutils literal notranslate"><span class="pre">fix_external_set_vector()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">flush_buffers</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/flush_buffers" title="f/_/flush_buffers"><code class="xref f f-subr docutils literal notranslate"><span class="pre">flush_buffers()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">is_running</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/is_running" title="f/_/is_running"><code class="xref f f-func docutils literal notranslate"><span class="pre">is_running()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">force_timeout</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/force_timeout" title="f/_/force_timeout"><code class="xref f f-subr docutils literal notranslate"><span class="pre">force_timeout()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">has_error</span><em> [</em><em>function</em><em>]</em> :: <a class="reference internal" href="#f/_/has_error" title="f/_/has_error"><code class="xref f f-func docutils literal notranslate"><span class="pre">has_error()</span></code></a></p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">get_last_error_message</span><em> [</em><em>subroutine</em><em>]</em> :: <a class="reference internal" href="#f/_/get_last_error_message" title="f/_/get_last_error_message"><code class="xref f f-subr docutils literal notranslate"><span class="pre">get_last_error_message()</span></code></a></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">lammps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">[args][,comm]</span></em><span class="sig-paren">)</span></dt>
<dd><p>This is the constructor for the Fortran class and will forward
the arguments to a call to either <a class="reference internal" href="Library_create.html#_CPPv419lammps_open_fortraniPPci" title="lammps_open_fortran"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_open_fortran()</span></code></a>
or <a class="reference internal" href="Library_create.html#_CPPv418lammps_open_no_mpiiPPcPPv" title="lammps_open_no_mpi"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_open_no_mpi()</span></code></a>. If the LAMMPS library has been
compiled with MPI support, it will also initialize MPI, if it has
not already been initialized before.</p>
<p>The <em>args</em> argument with the list of command line parameters is
optional and so it the <em>comm</em> argument with the MPI communicator.
If <em>comm</em> is not provided, <code class="docutils literal notranslate"><span class="pre">MPI_COMM_WORLD</span></code> is assumed. For
more details please see the documentation of <a class="reference internal" href="Library_create.html#_CPPv411lammps_openiPPc8MPI_CommPPv" title="lammps_open"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_open()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Options<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>args</strong><em> [</em><em>character(len=*),dimension(:),optional</em><em>]</em> :: arguments as list of strings</p></li>
<li><p><strong>comm</strong><em> [</em><em>integer,optional</em><em>]</em> :: MPI communicator</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_create.html#_CPPv419lammps_open_fortraniPPci" title="lammps_open_fortran"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_open_fortran()</span></code></a> <a class="reference internal" href="Library_create.html#_CPPv418lammps_open_no_mpiiPPcPPv" title="lammps_open_no_mpi"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_open_no_mpi()</span></code></a></p>
</dd>
<dt class="field-odd">Return<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>lammps</strong> :: an instance of the <a class="reference internal" href="#f/_/lammps" title="f/_/lammps"><code class="xref f f-type docutils literal notranslate"><span class="pre">lammps</span></code></a> derived type</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="xref f f-mod docutils literal notranslate"><span class="pre">MPI_F08</span></code> module, which defines Fortran 2008 bindings for MPI,
is not directly supported by this interface due to the complexities of
supporting both the <code class="xref f f-mod docutils literal notranslate"><span class="pre">MPI_F08</span></code> and <code class="xref f f-mod docutils literal notranslate"><span class="pre">MPI</span></code> modules at the same
time. However, you should be able to use the <code class="docutils literal notranslate"><span class="pre">MPI_VAL</span></code> member of the
<code class="docutils literal notranslate"><span class="pre">MPI_comm</span></code> derived type to access the integer value of the
communicator, such as in</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">PROGRAM </span><span class="n">testmpi</span>
<span class="w">  </span><span class="k">USE </span><span class="n">LIBLAMMPS</span>
<span class="w">  </span><span class="k">USE </span><span class="n">MPI_F08</span>
<span class="w">  </span><span class="k">TYPE</span><span class="p">(</span><span class="n">lammps</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">lmp</span>
<span class="w">  </span><span class="n">lmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lammps</span><span class="p">(</span><span class="n">comm</span><span class="o">=</span><span class="n">MPI_COMM_SELF</span><span class="p">%</span><span class="n">MPI_VAL</span><span class="p">)</span>
<span class="k">END PROGRAM </span><span class="n">testmpi</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl>
<dt class="sig sig-object f" id="f/_/lammps_style">
<em class="property"><span class="pre">type</span>&#160; </em><span class="sig-name descname"><span class="pre">lammps_style</span></span><a class="headerlink" href="#f/_/lammps_style" title="Permalink to this definition">¶</a></dt>
<dd><p>This derived type is there to provide a convenient interface for the style
constants used with <a class="reference internal" href="#f/_/extract_compute" title="f/_/extract_compute"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_compute()</span></code></a>, <a class="reference internal" href="#f/_/extract_fix" title="f/_/extract_fix"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_fix()</span></code></a>, and
<a class="reference internal" href="#f/_/extract_variable" title="f/_/extract_variable"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_variable()</span></code></a>. Assuming your LAMMPS instance is called <code class="docutils literal notranslate"><span class="pre">lmp</span></code>,
these constants will be <code class="docutils literal notranslate"><span class="pre">lmp%style%global</span></code>, <code class="docutils literal notranslate"><span class="pre">lmp%style%atom</span></code>,
and <code class="docutils literal notranslate"><span class="pre">lmp%style%local</span></code>. These values are identical to the values described
in <a class="reference internal" href="Library_objects.html#_CPPv416_LMP_STYLE_CONST" title="_LMP_STYLE_CONST"><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">_LMP_STYLE_CONST</span></code></a> for the C library interface.</p>
<dl class="field-list simple">
<dt class="field-odd">Type fields<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">global</span><em> [</em><em>integer(c_int)</em><em>]</em> :: used to request global data</p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">atom</span><em> [</em><em>integer(c_int)</em><em>]</em> :: used to request per-atom data</p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">local</span><em> [</em><em>integer(c_int)</em><em>]</em> :: used to request local data</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl>
<dt class="sig sig-object f" id="f/_/lammps_type">
<em class="property"><span class="pre">type</span>&#160; </em><span class="sig-name descname"><span class="pre">lammps_type</span></span><a class="headerlink" href="#f/_/lammps_type" title="Permalink to this definition">¶</a></dt>
<dd><p>This derived type is there to provide a convenient interface for the type
constants used with <a class="reference internal" href="#f/_/extract_compute" title="f/_/extract_compute"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_compute()</span></code></a>, <a class="reference internal" href="#f/_/extract_fix" title="f/_/extract_fix"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_fix()</span></code></a>, and
<a class="reference internal" href="#f/_/extract_variable" title="f/_/extract_variable"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_variable()</span></code></a>. Assuming your LAMMPS instance is called <code class="docutils literal notranslate"><span class="pre">lmp</span></code>,
these constants will be <code class="docutils literal notranslate"><span class="pre">lmp%type%scalar</span></code>, <code class="docutils literal notranslate"><span class="pre">lmp%type%vector</span></code>, and
<code class="docutils literal notranslate"><span class="pre">lmp%type%array</span></code>. These values are identical to the values described
in <a class="reference internal" href="Library_objects.html#_CPPv415_LMP_TYPE_CONST" title="_LMP_TYPE_CONST"><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">_LMP_TYPE_CONST</span></code></a> for the C library interface.</p>
<dl class="field-list simple">
<dt class="field-odd">Type fields<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">scalar</span><em> [</em><em>integer(c_int)</em><em>]</em> :: used to request scalars</p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">vector</span><em> [</em><em>integer(c_int)</em><em>]</em> :: used to request vectors</p></li>
<li><p><span class="sig-name descname">% </span><span class="sig-name descname">array</span><em> [</em><em>integer(c_int)</em><em>]</em> :: used to request arrays (matrices)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<section id="procedures-bound-to-the-lammps-derived-type">
<h2>Procedures Bound to the <a class="reference internal" href="#f/_/lammps" title="f/_/lammps"><code class="xref f f-type docutils literal notranslate"><span class="pre">lammps</span></code></a> Derived Type<a class="headerlink" href="#procedures-bound-to-the-lammps-derived-type" title="Permalink to this heading">¶</a></h2>
<dl>
<dt class="sig sig-object f" id="f/_/close">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="pre">finalize</span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#f/_/close" title="Permalink to this definition">¶</a></dt>
<dd><p>This method will close down the LAMMPS instance through calling
<a class="reference internal" href="Library_create.html#_CPPv412lammps_closePv" title="lammps_close"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_close()</span></code></a>.  If the <em>finalize</em> argument is present and
has a value of <code class="docutils literal notranslate"><span class="pre">.TRUE.</span></code>, then this subroutine also calls
<a class="reference internal" href="Library_create.html#_CPPv422lammps_kokkos_finalizev" title="lammps_kokkos_finalize"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_kokkos_finalize()</span></code></a> and
<a class="reference internal" href="Library_create.html#_CPPv419lammps_mpi_finalizev" title="lammps_mpi_finalize"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_mpi_finalize()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Options<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>finalize</strong><em> [</em><em>logical,optional</em><em>]</em> :: shut down the MPI environment of the LAMMPS
library if <code class="docutils literal notranslate"><span class="pre">.TRUE.</span></code>.</p>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_create.html#_CPPv412lammps_closePv" title="lammps_close"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_close()</span></code></a> <a class="reference internal" href="Library_create.html#_CPPv419lammps_mpi_finalizev" title="lammps_mpi_finalize"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_mpi_finalize()</span></code></a> <a class="reference internal" href="Library_create.html#_CPPv422lammps_kokkos_finalizev" title="lammps_kokkos_finalize"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_kokkos_finalize()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/error">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">error_type</span></em>, <em class="sig-param"><span class="pre">error_text</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/error" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is a wrapper around the <a class="reference internal" href="Library_create.html#_CPPv412lammps_errorPviPKc" title="lammps_error"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_error()</span></code></a> function and
will dispatch an error through the LAMMPS Error class.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>error_type</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: constant to select which Error class function to call</p></li>
<li><p><strong>error_text</strong><em> [</em><em>character(len=*)</em><em>]</em> :: error message</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_create.html#_CPPv412lammps_errorPviPKc" title="lammps_error"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_error()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/file">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">filename</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/file" title="Permalink to this definition">¶</a></dt>
<dd><p>This method will call <a class="reference internal" href="Library_execute.html#_CPPv411lammps_filePvPKc" title="lammps_file"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_file()</span></code></a> to have LAMMPS read
and process commands from a file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>filename</strong><em> [</em><em>character(len=*)</em><em>]</em> :: name of file with LAMMPS commands</p>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_execute.html#_CPPv411lammps_filePvPKc" title="lammps_file"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_file()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/command">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">command</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">cmd</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/command" title="Permalink to this definition">¶</a></dt>
<dd><p>This method will call <a class="reference internal" href="Library_execute.html#_CPPv414lammps_commandPvPKc" title="lammps_command"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_command()</span></code></a> to have LAMMPS
execute a single command.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cmd</strong><em> [</em><em>character(len=*)</em><em>]</em> :: single LAMMPS command</p>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_execute.html#_CPPv414lammps_commandPvPKc" title="lammps_command"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_command()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/commands_list">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">commands_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">cmds</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/commands_list" title="Permalink to this definition">¶</a></dt>
<dd><p>This method will call <a class="reference internal" href="Library_execute.html#_CPPv420lammps_commands_listPviPPKc" title="lammps_commands_list"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_commands_list()</span></code></a> to have LAMMPS
execute a list of input lines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cmd</strong><em> [</em><em>character(len=*)</em><em>,</em><em>dimension(:)</em><em>]</em> :: list of LAMMPS input lines</p>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_execute.html#_CPPv420lammps_commands_listPviPPKc" title="lammps_commands_list"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_commands_list()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/commands_string">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">commands_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">str</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/commands_string" title="Permalink to this definition">¶</a></dt>
<dd><p>This method will call <a class="reference internal" href="Library_execute.html#_CPPv422lammps_commands_stringPvPKc" title="lammps_commands_string"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_commands_string()</span></code></a> to have LAMMPS
execute a block of commands from a string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>str</strong><em> [</em><em>character(len=*)</em><em>]</em> :: LAMMPS input in string</p>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_execute.html#_CPPv422lammps_commands_stringPvPKc" title="lammps_commands_string"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_commands_string()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/get_natoms">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">get_natoms</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#f/_/get_natoms" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will call <a class="reference internal" href="Library_properties.html#_CPPv417lammps_get_natomsPv" title="lammps_get_natoms"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_get_natoms()</span></code></a> and return the number
of atoms in the system.</p>
<dl class="field-list simple">
<dt class="field-odd">Call to<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="Library_properties.html#_CPPv417lammps_get_natomsPv" title="lammps_get_natoms"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_get_natoms()</span></code></a></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>natoms</strong><em> [</em><em>real(c_double)</em><em>]</em> :: number of atoms</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you would prefer to get the number of atoms in its native format
(i.e., as a 32- or 64-bit integer, depending on how LAMMPS was compiled),
this can be extracted with <a class="reference internal" href="#f/_/extract_global" title="f/_/extract_global"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_global()</span></code></a>.</p>
</div>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/get_thermo">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">get_thermo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/get_thermo" title="Permalink to this definition">¶</a></dt>
<dd><p>This function will call <a class="reference internal" href="Library_properties.html#_CPPv417lammps_get_thermoPvPKc" title="lammps_get_thermo"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_get_thermo()</span></code></a> and return the value
of the corresponding thermodynamic keyword.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name</strong><em> [</em><em>character(len=*)</em><em>]</em> :: string with the name of the thermo keyword</p>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_properties.html#_CPPv417lammps_get_thermoPvPKc" title="lammps_get_thermo"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_get_thermo()</span></code></a></p>
</dd>
<dt class="field-odd">Return<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>value</strong><em> [</em><em>real(c_double)</em><em>]</em> :: value of the requested thermo property or <cite>0.0_c_double</cite></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/extract_box">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">extract_box</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">[boxlo][,</span> <span class="pre">boxhi][,</span> <span class="pre">xy][,</span> <span class="pre">yz][,</span> <span class="pre">xz][,</span> <span class="pre">pflags][,</span> <span class="pre">boxflag]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/extract_box" title="Permalink to this definition">¶</a></dt>
<dd><p>This subroutine will call <a class="reference internal" href="Library_properties.html#_CPPv418lammps_extract_boxPvPdPdPdPdPdPiPi" title="lammps_extract_box"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_extract_box()</span></code></a>. All
parameters are optional, though obviously at least one should be
present. The parameters <em>pflags</em> and <em>boxflag</em> are stored in LAMMPS
as integers, but should be declared as <code class="docutils literal notranslate"><span class="pre">LOGICAL</span></code> variables when
calling from Fortran.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Options<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>boxlo</strong><em> [</em><em>real(c_double)</em><em>,</em><em>dimension(3),optional</em><em>]</em> :: vector in which to store
lower-bounds of simulation box</p></li>
<li><p><strong>boxhi</strong><em> [</em><em>real(c_double)</em><em>,</em><em>dimension(3),optional</em><em>]</em> :: vector in which to store
upper-bounds of simulation box</p></li>
<li><p><strong>xy</strong><em> [</em><em>real(c_double)</em><em>,</em><em>optional</em><em>]</em> :: variable in which to store <em>xy</em> tilt factor</p></li>
<li><p><strong>yz</strong><em> [</em><em>real(c_double)</em><em>,</em><em>optional</em><em>]</em> :: variable in which to store <em>yz</em> tilt factor</p></li>
<li><p><strong>xz</strong><em> [</em><em>real(c_double)</em><em>,</em><em>optional</em><em>]</em> :: variable in which to store <em>xz</em> tilt factor</p></li>
<li><p><strong>pflags</strong><em> [</em><em>logical,dimension(3),optional</em><em>]</em> :: vector in which to store
periodicity flags (<code class="docutils literal notranslate"><span class="pre">.TRUE.</span></code> means periodic in that dimension)</p></li>
<li><p><strong>boxflag</strong><em> [</em><em>logical,optional</em><em>]</em> :: variable in which to store boolean denoting
whether the box will change during a simulation
(<code class="docutils literal notranslate"><span class="pre">.TRUE.</span></code> means box will change)</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_properties.html#_CPPv418lammps_extract_boxPvPdPdPdPdPdPiPi" title="lammps_extract_box"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_extract_box()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that a frequent use case of this function is to extract only one or
more of the options rather than all seven. For example, assuming “lmp”
represents a properly-initialized LAMMPS instance, the following code will
extract the periodic box settings into the variable “periodic”:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="c">! code to start up</span>
<span class="kt">LOGICAL</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">periodic</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="c">! code to initialize LAMMPS / run things / etc.</span>
<span class="k">CALL </span><span class="n">lmp</span><span class="p">%</span><span class="n">extract_box</span><span class="p">(</span><span class="n">pflags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">periodic</span><span class="p">)</span>
</pre></div>
</div>
</div>
<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/reset_box">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">reset_box</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">boxlo</span></em>, <em class="sig-param"><span class="pre">boxhi</span></em>, <em class="sig-param"><span class="pre">xy</span></em>, <em class="sig-param"><span class="pre">yz</span></em>, <em class="sig-param"><span class="pre">xz</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/reset_box" title="Permalink to this definition">¶</a></dt>
<dd><p>This subroutine will call <a class="reference internal" href="Library_properties.html#_CPPv416lammps_reset_boxPvPdPdddd" title="lammps_reset_box"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_reset_box()</span></code></a>. All parameters
are required.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>boxlo</strong><em> [</em><em>real(c_double)</em><em>,</em><em>dimension(3)</em><em>]</em> :: vector of three doubles containing
the lower box boundary</p></li>
<li><p><strong>boxhi</strong><em> [</em><em>real(c_double)</em><em>,</em><em>dimension(3)</em><em>]</em> :: vector of three doubles containing
the upper box boundary</p></li>
<li><p><strong>xy</strong><em> [</em><em>real(c_double)</em><em>]</em> :: <em>x–y</em> tilt factor</p></li>
<li><p><strong>yz</strong><em> [</em><em>real(c_double)</em><em>]</em> :: <em>y–z</em> tilt factor</p></li>
<li><p><strong>xz</strong><em> [</em><em>real(c_double)</em><em>]</em> :: <em>x–z</em> tilt factor</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_properties.html#_CPPv416lammps_reset_boxPvPdPdddd" title="lammps_reset_box"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_reset_box()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/memory_usage">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">memory_usage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">meminfo</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/memory_usage" title="Permalink to this definition">¶</a></dt>
<dd><p>This subroutine will call <a class="reference internal" href="Library_properties.html#_CPPv419lammps_memory_usagePvPd" title="lammps_memory_usage"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_memory_usage()</span></code></a> and store the
result in the three-element array <em>meminfo</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>meminfo</strong><em> [</em><em>real(c_double)</em><em>,</em><em>dimension(3)</em><em>]</em> :: vector of three doubles in which
to store memory usage data</p>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_properties.html#_CPPv419lammps_memory_usagePvPd" title="lammps_memory_usage"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_memory_usage()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/get_mpi_comm">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">get_mpi_comm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#f/_/get_mpi_comm" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns a Fortran representation of the LAMMPS “world”
communicator.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Call to<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="Library_properties.html#_CPPv419lammps_get_mpi_commPv" title="lammps_get_mpi_comm"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_get_mpi_comm()</span></code></a></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>comm</strong><em> [</em><em>integer</em><em>]</em> :: Fortran integer equivalent to the MPI communicator LAMMPS is
using</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The C library interface currently returns type <code class="docutils literal notranslate"><span class="pre">int</span></code> instead of
type <code class="docutils literal notranslate"><span class="pre">MPI_Fint</span></code>, which is the C type corresponding to Fortran
<code class="docutils literal notranslate"><span class="pre">INTEGER</span></code> types of the default kind.  On most compilers, these
are the same anyway, but this interface exchanges values this way
to avoid warning messages.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="xref f f-mod docutils literal notranslate"><span class="pre">MPI_F08</span></code> module, which defines Fortran 2008 bindings for MPI,
is not directly supported by this function.  However, you should be
able to convert between the two using the <cite>MPI_VAL</cite> member of the
communicator.  For example,</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">USE </span><span class="n">MPI_F08</span>
<span class="k">USE </span><span class="n">LIBLAMMPS</span>
<span class="k">TYPE</span><span class="p">(</span><span class="n">lammps</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">lmp</span>
<span class="k">TYPE</span><span class="p">(</span><span class="n">MPI_Comm</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">comm</span>
<span class="c">! ... [commands to set up LAMMPS/etc.]</span>
<span class="n">comm</span><span class="p">%</span><span class="n">MPI_VAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">get_mpi_comm</span><span class="p">()</span>
</pre></div>
</div>
<p>should assign an <code class="xref f f-mod docutils literal notranslate"><span class="pre">MPI_F08</span></code> communicator properly.</p>
</div>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/extract_setting">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">extract_setting</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">keyword</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/extract_setting" title="Permalink to this definition">¶</a></dt>
<dd><p>Query LAMMPS about global settings. See the documentation for the
<a class="reference internal" href="Library_properties.html#_CPPv422lammps_extract_settingPvPKc" title="lammps_extract_setting"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_extract_setting()</span></code></a> function from the C library.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>keyword</strong><em> [</em><em>character(len=*)</em><em>]</em> :: string containing the name of the thermo keyword</p>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_properties.html#_CPPv422lammps_extract_settingPvPKc" title="lammps_extract_setting"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_extract_setting()</span></code></a></p>
</dd>
<dt class="field-odd">Return<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>setting</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: value of the queried setting or <span class="math notranslate nohighlight">\(-1\)</span> if
unknown</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/extract_global">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">extract_global</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/extract_global" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls <a class="reference internal" href="Library_properties.html#_CPPv421lammps_extract_globalPvPKc" title="lammps_extract_global"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_extract_global()</span></code></a> and returns
either a string or a pointer to internal global LAMMPS data,
depending on the data requested through <em>name</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>Note that this function actually does not return a value, but rather
associates the pointer on the left side of the assignment to point to
internal LAMMPS data (with the exception of string data, which are
copied and returned as ordinary Fortran strings). Pointers must be of
the correct data type to point to said data (typically
<code class="docutils literal notranslate"><span class="pre">INTEGER(c_int)</span></code>, <code class="docutils literal notranslate"><span class="pre">INTEGER(c_int64_t)</span></code>, or <code class="docutils literal notranslate"><span class="pre">REAL(c_double)</span></code>)
and have compatible kind and rank.  The pointer being associated with
LAMMPS data is type-, kind-, and rank-checked at run-time via an
overloaded assignment operator.  The pointers returned by this
function are generally persistent; therefore it is not necessary to
call the function again unless a <a class="reference internal" href="clear.html"><span class="doc">clear command</span></a> command has been
issued, which wipes out and recreates the contents of the
<a class="reference internal" href="Classes_lammps.html#_CPPv4N9LAMMPS_NS6LAMMPSE" title="LAMMPS_NS::LAMMPS"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">LAMMPS</span></code></a> class.</p>
<p>For example,</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">PROGRAM </span><span class="n">demo</span>
<span class="w">  </span><span class="k">USE</span><span class="p">,</span><span class="w"> </span><span class="k">INTRINSIC</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="nb">ISO_C_BINDING</span><span class="p">,</span><span class="w"> </span><span class="k">ONLY</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">c_int64_t</span><span class="p">,</span><span class="w"> </span><span class="kt">c_int</span><span class="p">,</span><span class="w"> </span><span class="kt">c_double</span>
<span class="kt">  </span><span class="k">USE </span><span class="n">LIBLAMMPS</span>
<span class="w">  </span><span class="k">TYPE</span><span class="p">(</span><span class="n">lammps</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">lmp</span>
<span class="w">  </span><span class="kt">INTEGER</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span><span class="w"> </span><span class="k">POINTER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">nlocal</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">NULL</span><span class="p">()</span>
<span class="w">  </span><span class="kt">INTEGER</span><span class="p">(</span><span class="kt">c_int64_t</span><span class="p">),</span><span class="w"> </span><span class="k">POINTER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">ntimestep</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">NULL</span><span class="p">()</span>
<span class="w">  </span><span class="kt">REAL</span><span class="p">(</span><span class="kt">c_double</span><span class="p">),</span><span class="w"> </span><span class="k">POINTER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">NULL</span><span class="p">()</span>
<span class="w">  </span><span class="kt">CHARACTER</span><span class="p">(</span><span class="nb">LEN</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">units</span>
<span class="w">  </span><span class="n">lmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lammps</span><span class="p">()</span>
<span class="w">  </span><span class="c">! other commands</span>
<span class="w">  </span><span class="n">nlocal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">extract_global</span><span class="p">(</span><span class="s1">&#39;nlocal&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="n">ntimestep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">extract_global</span><span class="p">(</span><span class="s1">&#39;ntimestep&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="n">dt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">extract_global</span><span class="p">(</span><span class="s1">&#39;dt&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="n">units</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">extract_global</span><span class="p">(</span><span class="s1">&#39;units&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="c">! more commands</span>
<span class="w">  </span><span class="n">lmp</span><span class="p">.</span><span class="k">close</span><span class="p">(.</span><span class="n">TRUE</span><span class="p">.)</span>
<span class="k">END PROGRAM </span><span class="n">demo</span>
</pre></div>
</div>
<p>would extract the number of atoms on this processor, the current time step,
the size of the current time step, and the units being used into the
variables <em>nlocal</em>, <em>ntimestep</em>, <em>dt</em>, and <em>units</em>, respectively.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <a class="reference internal" href="#f/_/extract_global" title="f/_/extract_global"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_global()</span></code></a> returns a string, the string must have length
greater than or equal to the length of the string (not including the
terminal <code class="docutils literal notranslate"><span class="pre">NULL</span></code> character) that LAMMPS returns. If the variable’s
length is too short, the string will be truncated. As usual in Fortran,
strings are padded with spaces at the end. If you use an allocatable
string, the string <strong>must be allocated</strong> prior to calling this function,
but you can automatically reallocate it to the correct length after the
function returns, viz.,</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">PROGRAM </span><span class="n">test</span>
<span class="w">  </span><span class="k">USE </span><span class="n">LIBLAMMPS</span>
<span class="w">  </span><span class="k">TYPE</span><span class="p">(</span><span class="n">lammps</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">lmp</span>
<span class="w">  </span><span class="kt">CHARACTER</span><span class="p">(</span><span class="nb">LEN</span><span class="o">=</span><span class="p">:),</span><span class="w"> </span><span class="k">ALLOCATABLE</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">str</span>
<span class="w">  </span><span class="n">lmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lammps</span><span class="p">()</span>
<span class="w">  </span><span class="k">CALL </span><span class="n">lmp</span><span class="p">%</span><span class="n">command</span><span class="p">(</span><span class="s1">&#39;units metal&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="k">ALLOCATE</span><span class="p">(</span><span class="kt">CHARACTER</span><span class="p">(</span><span class="nb">LEN</span><span class="o">=</span><span class="mi">80</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">str</span><span class="p">)</span>
<span class="w">  </span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">extract_global</span><span class="p">(</span><span class="s1">&#39;units&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">TRIM</span><span class="p">(</span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="c">! re-allocates to length len_trim(str) here</span>
<span class="w">  </span><span class="k">PRINT</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="nb">LEN</span><span class="p">(</span><span class="n">str</span><span class="p">),</span><span class="w"> </span><span class="nb">LEN_TRIM</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
<span class="k">END PROGRAM </span><span class="n">test</span>
</pre></div>
</div>
<p>will print the number 5 (the length of the word “metal”) twice.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name</strong><em> [</em><em>character(len=*)</em><em>]</em> :: string with the name of the property to extract</p>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_properties.html#_CPPv421lammps_extract_globalPvPKc" title="lammps_extract_global"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_extract_global()</span></code></a></p>
</dd>
<dt class="field-odd">Return<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pointer</strong><em> [</em><em>polymorphic</em><em>]</em> :: pointer to LAMMPS data. The left-hand side of the
assignment should be either a string (if expecting string data) or a
C-compatible pointer (e.g., <code class="docutils literal notranslate"><span class="pre">INTEGER(c_int),</span> <span class="pre">POINTER</span> <span class="pre">::</span> <span class="pre">nlocal</span></code>) to the
extracted property. If expecting vector data, the pointer should have
dimension “:”.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Modifying the data in the location pointed to by the returned pointer
may lead to inconsistent internal data and thus may cause failures,
crashes, or bogus simulations.  In general, it is much better
to use a LAMMPS input command that sets or changes these parameters.
Using an input command will take care of all side effects and necessary
updates of settings derived from such settings.</p>
</div>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/extract_atom">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">extract_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/extract_atom" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls <a class="reference internal" href="Library_atoms.html#_CPPv419lammps_extract_atomPvPKc" title="lammps_extract_atom"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_extract_atom()</span></code></a> and returns a pointer to
LAMMPS data tied to the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Atom</span></code> class, depending on the data
requested through <em>name</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>Note that this function actually does not return a pointer, but rather
associates the pointer on the left side of the assignment to point
to internal LAMMPS data. Pointers must be of the correct type, kind, and
rank (e.g., <code class="docutils literal notranslate"><span class="pre">INTEGER(c_int),</span> <span class="pre">DIMENSION(:)</span></code> for “type”, “mask”, or “id”;
<code class="docutils literal notranslate"><span class="pre">INTEGER(c_int64_t),</span> <span class="pre">DIMENSION(:)</span></code> for “id” if LAMMPS was compiled
with the <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code> flag; <code class="docutils literal notranslate"><span class="pre">REAL(c_double),</span> <span class="pre">DIMENSION(:,:)</span></code> for
“x”, “v”, or “f”; and so forth). The pointer being associated with LAMMPS
data is type-, kind-, and rank-checked at run-time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name</strong><em> [</em><em>character(len=*)</em><em>]</em> :: string with the name of the property to extract</p>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_atoms.html#_CPPv419lammps_extract_atomPvPKc" title="lammps_extract_atom"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_extract_atom()</span></code></a></p>
</dd>
<dt class="field-odd">Return<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pointer</strong><em> [</em><em>polymorphic</em><em>]</em> :: pointer to LAMMPS data. The left-hand side of the
assignment should be a C-interoperable pointer of appropriate kind and rank
(e.g., <code class="docutils literal notranslate"><span class="pre">INTEGER(c_int),</span> <span class="pre">POINTER</span> <span class="pre">::</span> <span class="pre">mask(:)</span></code>) to the extracted
property. If expecting vector data, the pointer should have dimension “:”;
if expecting matrix data, the pointer should have dimension “:,:”.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Pointers returned by this function are generally not persistent, as
per-atom data may be redistributed, reallocated, and reordered at every
re-neighboring operation. It is advisable to re-bind pointers using
<a class="reference internal" href="#f/_/extract_atom" title="f/_/extract_atom"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_atom()</span></code></a> between runs.</p>
</div>
<div class="admonition-array-index-order admonition">
<p class="admonition-title">Array index order</p>
<p>Two-dimensional arrays returned from <a class="reference internal" href="#f/_/extract_atom" title="f/_/extract_atom"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_atom()</span></code></a> will be
<strong>transposed</strong> from equivalent arrays in C, and they will be indexed
from 1 instead of 0. For example, in C,</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">lmp</span><span class="p">;</span>
<span class="kt">double</span><span class="w"> </span><span class="o">**</span><span class="n">x</span><span class="p">;</span>
<span class="cm">/* more code to setup, etc. */</span>
<span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lammps_extract_atom</span><span class="p">(</span><span class="n">lmp</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;x&quot;</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
</pre></div>
</div>
<p>will print the <em>y</em>-coordinate of the sixth atom on this processor.
Conversely,</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">TYPE</span><span class="p">(</span><span class="n">lammps</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">lmp</span>
<span class="kt">REAL</span><span class="p">(</span><span class="kt">c_double</span><span class="p">),</span><span class="w"> </span><span class="k">DIMENSION</span><span class="p">(:,:),</span><span class="w"> </span><span class="k">POINTER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">NULL</span><span class="p">()</span>
<span class="c">! more code to setup, etc.</span>
<span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">extract_atom</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
<span class="k">PRINT</span><span class="w"> </span><span class="s1">&#39;(f0.6)&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<p>will print the <em>y</em>-coordinate of the sixth atom on this processor
(note the transposition of the two indices). This is not a choice, but
rather a consequence of the different conventions adopted by the Fortran
and C standards decades ago: in C, the block of data</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
</pre></div>
</div>
<p>interpreted as a <span class="math notranslate nohighlight">\(4\times4\)</span> matrix would be</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
  1 &amp; 2 &amp; 3 &amp; 4 \\
  5 &amp; 6 &amp; 7 &amp; 8 \\
  9 &amp; 10 &amp; 11 &amp; 12 \\
  13 &amp; 14 &amp; 15 &amp; 16
\end{bmatrix},\end{split}\]</div>
<p>that is, in row-major order. In Fortran, the same block of data is
interpreted in column-major order, namely,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
  1 &amp; 5 &amp; 9  &amp; 13 \\
  2 &amp; 6 &amp; 10 &amp; 14 \\
  3 &amp; 7 &amp; 11 &amp; 15 \\
  4 &amp; 8 &amp; 12 &amp; 16
\end{bmatrix}.\end{split}\]</div>
<p>This difference in interpretation of the same block of data by the two
languages means, in effect, that matrices from C or C++ will be
transposed when interpreted in Fortran.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you would like the indices to start at 0 instead of 1 (which follows
typical notation in C and C++, but not Fortran), you can create another
pointer and associate it thus:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="kt">REAL</span><span class="p">(</span><span class="kt">c_double</span><span class="p">),</span><span class="w"> </span><span class="k">DIMENSION</span><span class="p">(:,:),</span><span class="w"> </span><span class="k">POINTER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x0</span>
<span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">extract_atom</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
<span class="n">x0</span><span class="p">(</span><span class="mi">0</span><span class="p">:,</span><span class="mi">0</span><span class="p">:)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">x</span>
</pre></div>
</div>
<p>The above would cause the dimensions of <em>x</em> to be (1:3, 1:nmax)
and those of <em>x0</em> to be (0:2, 0:nmax<span class="math notranslate nohighlight">\(-\)</span>1).</p>
</div>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/extract_compute">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">extract_compute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">id</span></em>, <em class="sig-param"><span class="pre">style</span></em>, <em class="sig-param"><span class="pre">type</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/extract_compute" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls <a class="reference internal" href="Library_objects.html#_CPPv422lammps_extract_computePvPKcii" title="lammps_extract_compute"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_extract_compute()</span></code></a> and returns a pointer
to LAMMPS data tied to the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Compute</span></code> class, specifically data
provided by the compute identified by <em>id</em>. Computes may provide global,
per-atom, or local data, and those data may be a scalar, a vector, or an
array. Since computes may provide multiple kinds of data, the user is
required to specify which set of data is to be returned through the
<em>style</em> and <em>type</em> variables.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>Note that this function actually does not return a value, but rather
associates the pointer on the left side of the assignment to point to
internal LAMMPS data. Pointers must be of the correct data type to point to
said data (i.e., <code class="docutils literal notranslate"><span class="pre">REAL(c_double)</span></code>) and have compatible rank.  The pointer
being associated with LAMMPS data is type-, kind-, and rank-checked at
run-time via an overloaded assignment operator.</p>
<p>For example,</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">TYPE</span><span class="p">(</span><span class="n">lammps</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">lmp</span>
<span class="kt">REAL</span><span class="p">(</span><span class="kt">c_double</span><span class="p">),</span><span class="w"> </span><span class="k">DIMENSION</span><span class="p">(:),</span><span class="w"> </span><span class="k">POINTER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">COM</span>
<span class="c">! code to setup, create atoms, etc.</span>
<span class="k">CALL </span><span class="n">lmp</span><span class="p">%</span><span class="n">command</span><span class="p">(</span><span class="s1">&#39;compute COM all com&#39;</span><span class="p">)</span>
<span class="n">COM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">extract_compute</span><span class="p">(</span><span class="s1">&#39;COM&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">style</span><span class="p">%</span><span class="n">global</span><span class="p">,</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">style</span><span class="p">%</span><span class="k">type</span><span class="p">)</span>
</pre></div>
</div>
<p>will bind the variable <em>COM</em> to the center of mass of the atoms created in
your simulation. The vector in this case has length 3; the length (or, in
the case of array data, the number of rows and columns) is determined for
you based on data from the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Compute</span></code> class.</p>
<div class="admonition-array-index-order admonition">
<p class="admonition-title">Array index order</p>
<p>Two-dimensional arrays returned from <a class="reference internal" href="#f/_/extract_compute" title="f/_/extract_compute"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_compute()</span></code></a> will be
<strong>transposed</strong> from equivalent arrays in C, and they will be indexed
from 1 instead of 0. See the note at <a class="reference internal" href="#f/_/extract_atom" title="f/_/extract_atom"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_atom()</span></code></a> for
further details.</p>
</div>
<p>The following combinations are possible (assuming <code class="docutils literal notranslate"><span class="pre">lmp</span></code> is the name of
your LAMMPS instance):</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Style</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Type to assign to</p></th>
<th class="head"><p>Returned data</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">lmp%style%global</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">lmp%type%scalar</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">REAL(c_double),</span> <span class="pre">POINTER</span></code></p></td>
<td><p>Global scalar</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">lmp%style%global</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">lmp%type%vector</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">REAL(c_double),</span> <span class="pre">DIMENSION(:),</span> <span class="pre">POINTER</span></code></p></td>
<td><p>Global vector</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">lmp%style%global</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">lmp%type%array</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">REAL(c_double),</span> <span class="pre">DIMENSION(:,:),</span> <span class="pre">POINTER</span></code></p></td>
<td><p>Global array</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">lmp%style%atom</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">lmp%type%vector</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">REAL(c_double),</span> <span class="pre">DIMENSION(:),</span> <span class="pre">POINTER</span></code></p></td>
<td><p>Per-atom vector</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">lmp%style%atom</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">lmp%type%array</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">REAL(c_double),</span> <span class="pre">DIMENSION(:,:),</span> <span class="pre">POINTER</span></code></p></td>
<td><p>Per-atom array</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">lmp%style%local</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">lmp%type%vector</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">REAL(c_double),</span> <span class="pre">DIMENSION(:),</span> <span class="pre">POINTER</span></code></p></td>
<td><p>Local vector</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">lmp%style%local</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">lmp%type%array</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">REAL(c_double),</span> <span class="pre">DIMENSION(:,:),</span> <span class="pre">POINTER</span></code></p></td>
<td><p>Local array</p></td>
</tr>
</tbody>
</table>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>id</strong><em> [</em><em>character(len=*)</em><em>]</em> :: compute ID from which to extract data</p></li>
<li><p><strong>style</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: value indicating the style of data to extract
(global, per-atom, or local)</p></li>
<li><p><strong>type</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: value indicating the type of data to extract
(scalar, vector, or array)</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_objects.html#_CPPv422lammps_extract_computePvPKcii" title="lammps_extract_compute"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_extract_compute()</span></code></a></p>
</dd>
<dt class="field-odd">Return<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pointer</strong><em> [</em><em>polymorphic</em><em>]</em> :: pointer to LAMMPS data. The left-hand side of the assignment
should be a C-compatible pointer (e.g., <code class="docutils literal notranslate"><span class="pre">REAL(c_double),</span> <span class="pre">POINTER</span> <span class="pre">::</span> <span class="pre">x</span></code>)
to the extracted property. If expecting vector data, the pointer should
have dimension “:”; if expecting array (matrix) data, the pointer should
have dimension “:,:”.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the compute’s data are not already computed for the current step, the
compute will be invoked. LAMMPS cannot easily check at that time if it is
valid to invoke a compute, so it may fail with an error. The caller has
to check to avoid such an error.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The pointers returned by this function are generally not persistent,
since the computed data may be re-distributed, re-allocated, and
re-ordered at every invocation. It is advisable to re-invoke this
function before the data are accessed or make a copy if the data are to
be used after other LAMMPS commands have been issued. Do <strong>not</strong> modify
the data returned by this function.</p>
</div>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/extract_fix">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">extract_fix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">id,</span> <span class="pre">style,</span> <span class="pre">type[,</span> <span class="pre">nrow][,</span> <span class="pre">ncol]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/extract_fix" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls <a class="reference internal" href="Library_objects.html#_CPPv418lammps_extract_fixPvPKciiii" title="lammps_extract_fix"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_extract_fix()</span></code></a> and returns a pointer to
LAMMPS data tied to the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Fix</span></code> class, specifically data provided
by the fix identified by <em>id</em>. Fixes may provide global, per-atom, or
local data, and those data may be a scalar, a vector, or an array. Since
many fixes provide multiple kinds of data, the user is required to specify
which set of data is to be returned through the <em>style</em> and <em>type</em>
variables.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>Global data are calculated at the time they are requested and are only
available element-by-element. As such, the user is expected to provide
the <em>nrow</em> variable to specify which element of a global vector or the
<em>nrow</em> and <em>ncol</em> variables to specify which element of a global array the
user wishes LAMMPS to return. The <em>ncol</em> variable is optional for global
scalar or vector data, and both <em>nrow</em> and <em>ncol</em> are optional when a
global scalar is requested, as well as when per-atom or local data are
requested. The following combinations are possible (assuming <code class="docutils literal notranslate"><span class="pre">lmp</span></code> is the
name of your LAMMPS instance):</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Style</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>nrow</p></th>
<th class="head"><p>ncol</p></th>
<th class="head"><p>Type to assign to</p></th>
<th class="head"><p>Returned data</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">lmp%style%global</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">lmp%type%scalar</span></code></p></td>
<td><p>Ignored</p></td>
<td><p>Ignored</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">REAL(c_double)</span></code></p></td>
<td><p>Global scalar</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">lmp%style%global</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">lmp%type%vector</span></code></p></td>
<td><p>Required</p></td>
<td><p>Ignored</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">REAL(c_double)</span></code></p></td>
<td><p>Element of global vector</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">lmp%style%global</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">lmp%type%array</span></code></p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">REAL(c_double)</span></code></p></td>
<td><p>Element of global array</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">lmp%style%atom</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">lmp%type%scalar</span></code></p></td>
<td></td>
<td></td>
<td></td>
<td><p>(not allowed)</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">lmp%style%atom</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">lmp%type%vector</span></code></p></td>
<td><p>Ignored</p></td>
<td><p>Ignored</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">REAL(c_double),</span> <span class="pre">DIMENSION(:),</span> <span class="pre">POINTER</span></code></p></td>
<td><p>Per-atom vector</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">lmp%style%atom</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">lmp%type%array</span></code></p></td>
<td><p>Ignored</p></td>
<td><p>Ignored</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">REAL(c_double),</span> <span class="pre">DIMENSION(:,:),</span> <span class="pre">POINTER</span></code></p></td>
<td><p>Per-atom array</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">lmp%style%local</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">lmp%type%scalar</span></code></p></td>
<td></td>
<td></td>
<td></td>
<td><p>(not allowed)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">lmp%style%local</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">lmp%type%vector</span></code></p></td>
<td><p>Ignored</p></td>
<td><p>Ignored</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">REAL(c_double),</span> <span class="pre">DIMENSION(:),</span> <span class="pre">POINTER</span></code></p></td>
<td><p>Per-atom vector</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">lmp%style%local</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">lmp%type%array</span></code></p></td>
<td><p>Ignored</p></td>
<td><p>Ignored</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">REAL(c_double),</span> <span class="pre">DIMENSION(:,:),</span> <span class="pre">POINTER</span></code></p></td>
<td><p>Per-atom array</p></td>
</tr>
</tbody>
</table>
<p>In the case of global data, this function returns a value of type
<code class="docutils literal notranslate"><span class="pre">REAL(c_double)</span></code>. For per-atom or local data, this function does not
return a value but instead associates the pointer on the left side of the
assignment to point to internal LAMMPS data. Pointers must be of the correct
type and kind to point to said data (i.e., <code class="docutils literal notranslate"><span class="pre">REAL(c_double)</span></code>) and have
compatible rank.  The pointer being associated with LAMMPS data is type-,
kind-, and rank-checked at run-time via an overloaded assignment operator.</p>
<p>For example,</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">TYPE</span><span class="p">(</span><span class="n">lammps</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">lmp</span>
<span class="kt">REAL</span><span class="p">(</span><span class="kt">c_double</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">dr</span><span class="p">,</span><span class="w"> </span><span class="n">dx</span><span class="p">,</span><span class="w"> </span><span class="n">dy</span><span class="p">,</span><span class="w"> </span><span class="n">dz</span>
<span class="c">! more code to set up, etc.</span>
<span class="n">lmp</span><span class="p">%</span><span class="n">command</span><span class="p">(</span><span class="s1">&#39;fix george all recenter 2 2 2&#39;</span><span class="p">)</span>
<span class="c">! more code</span>
<span class="n">dr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">extract_fix</span><span class="p">(</span><span class="s2">&quot;george&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">style</span><span class="p">%</span><span class="n">global</span><span class="p">,</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">style</span><span class="p">%</span><span class="n">scalar</span><span class="p">)</span>
<span class="n">dx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">extract_fix</span><span class="p">(</span><span class="s2">&quot;george&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">style</span><span class="p">%</span><span class="n">global</span><span class="p">,</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">style</span><span class="p">%</span><span class="n">vector</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="n">dy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">extract_fix</span><span class="p">(</span><span class="s2">&quot;george&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">style</span><span class="p">%</span><span class="n">global</span><span class="p">,</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">style</span><span class="p">%</span><span class="n">vector</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="n">dz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">extract_fix</span><span class="p">(</span><span class="s2">&quot;george&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">style</span><span class="p">%</span><span class="n">global</span><span class="p">,</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">style</span><span class="p">%</span><span class="n">vector</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>will extract the global scalar calculated by
<a class="reference internal" href="fix_recenter.html"><span class="doc">fix recenter</span></a> into the variable <em>dr</em> and the
three elements of the global vector calculated by fix recenter into the
variables <em>dx</em>, <em>dy</em>, and <em>dz</em>, respectively.</p>
<p>If asked for per-atom or local data, <a class="reference internal" href="#f/_/extract_compute" title="f/_/extract_compute"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_compute()</span></code></a> returns a
pointer to actual LAMMPS data. The pointer so returned will have the
appropriate size to match the internal data, and will be
type/kind/rank-checked at the time of the assignment. For example,</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">TYPE</span><span class="p">(</span><span class="n">lammps</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">lmp</span>
<span class="kt">REAL</span><span class="p">(</span><span class="kt">c_double</span><span class="p">),</span><span class="w"> </span><span class="k">DIMENSION</span><span class="p">(:),</span><span class="w"> </span><span class="k">POINTER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">r</span>
<span class="c">! more code to set up, etc.</span>
<span class="n">lmp</span><span class="p">%</span><span class="n">command</span><span class="p">(</span><span class="s1">&#39;fix state all store/state 0 x y z&#39;</span><span class="p">)</span>
<span class="c">! more code</span>
<span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">extract_fix</span><span class="p">(</span><span class="s1">&#39;state&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">style</span><span class="p">%</span><span class="n">atom</span><span class="p">,</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="k">type</span><span class="p">%</span><span class="k">array</span><span class="p">)</span>
</pre></div>
</div>
<p>will bind the pointer <em>r</em> to internal LAMMPS data representing the per-atom
array computed by <a class="reference internal" href="fix_store_state.html"><span class="doc">fix store/state</span></a> when three
inputs are specified. Similarly,</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">TYPE</span><span class="p">(</span><span class="n">lammps</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">lmp</span>
<span class="kt">REAL</span><span class="p">(</span><span class="kt">c_double</span><span class="p">),</span><span class="w"> </span><span class="k">DIMENSION</span><span class="p">(:),</span><span class="w"> </span><span class="k">POINTER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span>
<span class="c">! more code to set up, etc.</span>
<span class="n">lmp</span><span class="p">%</span><span class="n">command</span><span class="p">(</span><span class="s1">&#39;fix state all store/state 0 x&#39;</span><span class="p">)</span>
<span class="c">! more code</span>
<span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">extract_fix</span><span class="p">(</span><span class="s1">&#39;state&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">style</span><span class="p">%</span><span class="n">atom</span><span class="p">,</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="k">type</span><span class="p">%</span><span class="n">vector</span><span class="p">)</span>
</pre></div>
</div>
<p>will associate the pointer <em>x</em> with internal LAMMPS data corresponding to
the per-atom vector computed by <a class="reference internal" href="fix_store_state.html"><span class="doc">fix store/state</span></a>
when only one input is specified. Similar examples with <code class="docutils literal notranslate"><span class="pre">lmp%style%atom</span></code>
replaced by <code class="docutils literal notranslate"><span class="pre">lmp%style%local</span></code> will extract local data from fixes that
define local vectors and/or arrays.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The pointers returned by this function for per-atom or local data are
generally not persistent, since the computed data may be redistributed,
reallocated, and reordered at every invocation of the fix.  It is thus
advisable to re-invoke this function before the data are accessed or to
make a copy if the data are to be used after other LAMMPS commands have
been issued.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>LAMMPS cannot easily check if it is valid to access the data, so it
may fail with an error.  The caller has to avoid such an error.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>id</strong><em> [</em><em>character(len=*)</em><em>]</em> :: string with the name of the fix from which
to extract data</p></li>
<li><p><strong>style</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: value indicating the style of data to extract
(global, per-atom, or local)</p></li>
<li><p><strong>type</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: value indicating the type of data to extract
(scalar, vector, or array)</p></li>
<li><p><strong>nrow</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: row index (used only for global vectors and arrays)</p></li>
<li><p><strong>ncol</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: column index (only used for global arrays)</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_objects.html#_CPPv418lammps_extract_fixPvPKciiii" title="lammps_extract_fix"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_extract_fix()</span></code></a></p>
</dd>
<dt class="field-odd">Return<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong><em> [</em><em>polymorphic</em><em>]</em> :: LAMMPS data (for global data) or a pointer to LAMMPS data
(for per-atom or local data). The left-hand side of the assignment should
be of type <code class="docutils literal notranslate"><span class="pre">REAL(c_double)</span></code> and have appropriate rank (i.e.,
<code class="docutils literal notranslate"><span class="pre">DIMENSION(:)</span></code> if expecting per-atom or local vector data and
<code class="docutils literal notranslate"><span class="pre">DIMENSION(:,:)</span></code> if expecting per-atom or local array data). If expecting
local or per-atom data, it should have the <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> attribute, but
if expecting global data, it should be an ordinary (non-<code class="docutils literal notranslate"><span class="pre">POINTER</span></code>)
variable.</p>
</dd>
</dl>
<div class="admonition-array-index-order admonition">
<p class="admonition-title">Array index order</p>
<p>Two-dimensional global, per-atom, or local array data from
<a class="reference internal" href="#f/_/extract_fix" title="f/_/extract_fix"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_fix()</span></code></a> will be <strong>transposed</strong> from equivalent arrays in
C (or in the ordinary LAMMPS interface accessed through thermodynamic
output), and they will be indexed from 1, not 0. This is true even for
global data, which are returned as scalars—this is done primarily so
the interface is consistent, as there is no choice but to transpose the
indices for per-atom or local array data. See the similar note under
<a class="reference internal" href="#f/_/extract_atom" title="f/_/extract_atom"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_atom()</span></code></a> for further details.</p>
</div>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/extract_variable">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">extract_variable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">group</span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#f/_/extract_variable" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls <a class="reference internal" href="Library_objects.html#_CPPv423lammps_extract_variablePvPKcPKc" title="lammps_extract_variable"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_extract_variable()</span></code></a> and returns a
scalar, vector, or string containing the value of the variable identified by
<em>name</em>. When the variable is an <em>equal</em>-style variable (or one compatible
with that style such as <em>internal</em>), the variable is evaluated and the
corresponding value returned. When the variable is an <em>atom</em>-style variable,
the variable is evaluated and a vector of values is returned. With all
other variables, a string is returned. The <em>group</em> argument is only used
for <em>atom</em> style variables and is ignored otherwise. If <em>group</em> is absent
for <em>atom</em>-style variables, the group is assumed to be “all”.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>This function returns the values of the variables, not pointers to them.
Vectors pointing to <em>atom</em>-style variables should be of type
<code class="docutils literal notranslate"><span class="pre">REAL(c_double)</span></code>, be of rank 1 (i.e., <code class="docutils literal notranslate"><span class="pre">DIMENSION(:)</span></code>), and have the
<code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> attribute.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unlike the C library interface, the Fortran interface does not require
you to deallocate memory when you are through; this is done for you,
behind the scenes.</p>
</div>
<p>For example,</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">TYPE</span><span class="p">(</span><span class="n">lammps</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">lmp</span>
<span class="kt">REAL</span><span class="p">(</span><span class="kt">c_double</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">area</span>
<span class="c">! more code to set up, etc.</span>
<span class="n">lmp</span><span class="p">%</span><span class="n">command</span><span class="p">(</span><span class="s1">&#39;variable A equal lx*ly&#39;</span><span class="p">)</span>
<span class="c">! more code</span>
<span class="n">area</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">extract_variable</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>will extract the <em>x</em>–<em>y</em> cross-sectional area of the simulation into the
variable <em>area</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>name</strong><em> [</em><em>character(len=*)</em><em>]</em> :: variable name to evaluate</p>
</dd>
<dt class="field-even">Options<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>group</strong><em> [</em><em>character(len=*)</em><em>,</em><em>optional</em><em>]</em> :: group for which to extract per-atom
data (if absent, use “all”)</p>
</dd>
<dt class="field-odd">Call to<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="Library_objects.html#_CPPv423lammps_extract_variablePvPKcPKc" title="lammps_extract_variable"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_extract_variable()</span></code></a></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>data</strong><em> [</em><em>polymorphic</em><em>]</em> :: scalar of type <code class="docutils literal notranslate"><span class="pre">REAL(c_double)</span></code> (for <em>equal</em>-style
variables and others that are <em>equal</em>-compatible), vector of type
<code class="docutils literal notranslate"><span class="pre">REAL(c_double),</span> <span class="pre">DIMENSION(:),</span> <span class="pre">ALLOCATABLE</span></code> for <em>atom</em>- or <em>vector</em>-style
variables, or <code class="docutils literal notranslate"><span class="pre">CHARACTER(LEN=*)</span></code> for <em>string</em>-style and compatible
variables. Strings whose length is too short to hold the result will be
truncated. Allocatable strings must be allocated before this function is
called; see note at <a class="reference internal" href="#f/_/extract_global" title="f/_/extract_global"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_global()</span></code></a> regarding allocatable strings.
Allocatable arrays (for <em>atom</em>- and <em>vector</em>-style data) will be
reallocated on assignment.</p>
</dd>
</dl>
</dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>LAMMPS cannot easily check if it is valid to access the data
referenced by the variables (e.g., computes, fixes, or thermodynamic
info), so it may fail with an error.  The caller has to make certain
that the data are extracted only when it is safe to evaluate the variable
and thus an error and crash are avoided.</p>
</div>
<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/set_variable">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">set_variable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">str</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/set_variable" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the value of a string-style variable.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>This function assigns a new value from the string <em>str</em> to the string-style
variable <em>name</em>. If <em>name</em> does not exist or is not a string-style
variable, an error is generated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong><em> [</em><em>character(len=*)</em><em>]</em> :: name of the variable</p></li>
<li><p><strong>str</strong><em> [</em><em>character(len=*)</em><em>]</em> :: new value to assign to the variable</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_objects.html#_CPPv419lammps_set_variablePvPcPc" title="lammps_set_variable"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_set_variable()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/gather_atoms">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">gather_atoms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">count</span></em>, <em class="sig-param"><span class="pre">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/gather_atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls <a class="reference internal" href="Library_scatter.html#_CPPv419lammps_gather_atomsPvPKciiPv" title="lammps_gather_atoms"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_gather_atoms()</span></code></a> to gather the named
atom-based entity for all atoms on all processors and return it in the
vector <em>data</em>. The vector <em>data</em> will be ordered by atom
ID, which requires consecutive atom IDs (1 to <em>natoms</em>).</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>If you need a similar array but have non-consecutive atom IDs, see
<a class="reference internal" href="#f/_/gather_atoms_concat" title="f/_/gather_atoms_concat"><code class="xref f f-func docutils literal notranslate"><span class="pre">gather_atoms_concat()</span></code></a>; for a similar array but for a subset
of atoms, see <a class="reference internal" href="#f/_/gather_atoms_subset" title="f/_/gather_atoms_subset"><code class="xref f f-func docutils literal notranslate"><span class="pre">gather_atoms_subset()</span></code></a>.</p>
<p>The <em>data</em> array will be ordered in groups of <em>count</em> values, sorted by atom
ID (e.g., if <em>name</em> is <em>x</em> and <em>count</em> = 3, then <em>data</em> = [<em>x</em>(1,1),
<em>x</em>(2,1), <em>x</em>(3,1), <em>x</em>(1,2), <em>x</em>(2,2), <em>x</em>(3,2), <em>x</em>(1,3),
<span class="math notranslate nohighlight">\(\dots\)</span>]); <em>data</em> must be <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> and will be allocated to
length (<em>count</em> <span class="math notranslate nohighlight">\(\times\)</span> <em>natoms</em>), as queried by
<a class="reference internal" href="#f/_/get_natoms" title="f/_/get_natoms"><code class="xref f f-func docutils literal notranslate"><span class="pre">get_natoms()</span></code></a>.</p>
<p>This function is not compatible with <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong><em> [</em><em>character(len=*)</em><em>]</em> :: desired quantity (e.g., <em>x</em> or <em>mask</em>)</p></li>
<li><p><strong>count</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: number of per-atom values you expect per atom
(e.g., 1 for <em>type</em>, <em>mask</em>, or <em>charge</em>; 3 for <em>x</em>, <em>v</em>, or <em>f</em>). Use
<em>count</em> = 3 with <em>image</em> if you want a single image flag unpacked into
<em>x</em>/<em>y</em>/<em>z</em> components.</p></li>
<li><p><strong>data</strong><em> [</em><em>polymorphic,dimension(:),allocatable</em><em>]</em> :: array into which to store
the data. Array <em>must</em> have the <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> attribute and be of rank 1
(i.e., <code class="docutils literal notranslate"><span class="pre">DIMENSION(:)</span></code>). If this array is already allocated, it will be
reallocated to fit the length of the incoming data. It should have type
<code class="docutils literal notranslate"><span class="pre">INTEGER(c_int)</span></code> if expecting integer data and <code class="docutils literal notranslate"><span class="pre">REAL(c_double)</span></code> if
expecting floating-point data.</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_scatter.html#_CPPv419lammps_gather_atomsPvPKciiPv" title="lammps_gather_atoms"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_gather_atoms()</span></code></a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you want data from this function to be accessible as a two-dimensional
array, you can declare a rank-2 pointer and reassign it, like so:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">USE</span><span class="p">,</span><span class="w"> </span><span class="k">INTRINSIC</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="nb">ISO_C_BINDING</span>
<span class="k">USE </span><span class="n">LIBLAMMPS</span>
<span class="k">TYPE</span><span class="p">(</span><span class="n">lammps</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">lmp</span>
<span class="kt">REAL</span><span class="p">(</span><span class="kt">c_double</span><span class="p">),</span><span class="w"> </span><span class="k">DIMENSION</span><span class="p">(:),</span><span class="w"> </span><span class="k">ALLOCATABLE</span><span class="p">,</span><span class="w"> </span><span class="k">TARGET</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">xdata</span>
<span class="kt">REAL</span><span class="p">(</span><span class="kt">c_double</span><span class="p">),</span><span class="w"> </span><span class="k">DIMENSION</span><span class="p">(:,:),</span><span class="w"> </span><span class="k">POINTER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span>
<span class="c">! other code to set up, etc.</span>
<span class="k">CALL </span><span class="n">lmp</span><span class="p">%</span><span class="n">gather_atoms</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">xdata</span><span class="p">)</span>
<span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">size</span><span class="p">(</span><span class="n">xdata</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">xdata</span>
</pre></div>
</div>
<p>You can then access the <em>y</em>-component of atom 3 with <code class="docutils literal notranslate"><span class="pre">x(2,3)</span></code>.
See the note about array index order at <a class="reference internal" href="#f/_/extract_atom" title="f/_/extract_atom"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_atom()</span></code></a>.</p>
</div>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/gather_atoms_concat">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">gather_atoms_concat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">count</span></em>, <em class="sig-param"><span class="pre">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/gather_atoms_concat" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls <a class="reference internal" href="Library_scatter.html#_CPPv426lammps_gather_atoms_concatPvPKciiPv" title="lammps_gather_atoms_concat"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_gather_atoms_concat()</span></code></a> to gather the
named atom-based entity for all atoms on all processors and return it in the
vector <em>data</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>The vector <em>data</em> will not be ordered by atom ID, and there is no
restriction on the IDs being consecutive. If you need the IDs, you can do
another <a class="reference internal" href="#f/_/gather_atoms_concat" title="f/_/gather_atoms_concat"><code class="xref f f-func docutils literal notranslate"><span class="pre">gather_atoms_concat()</span></code></a> with <em>name</em> set to <code class="docutils literal notranslate"><span class="pre">id</span></code>.</p>
<p>If you need a similar array but have consecutive atom IDs, see
<a class="reference internal" href="#f/_/gather_atoms" title="f/_/gather_atoms"><code class="xref f f-func docutils literal notranslate"><span class="pre">gather_atoms()</span></code></a>; for a similar array but for a subset of atoms, see
<a class="reference internal" href="#f/_/gather_atoms_subset" title="f/_/gather_atoms_subset"><code class="xref f f-func docutils literal notranslate"><span class="pre">gather_atoms_subset()</span></code></a>.</p>
<p>This function is not compatible with <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong><em> [</em><em>character(len=*)</em><em>]</em> :: desired quantity (e.g., <em>x</em> or <em>mask</em>)</p></li>
<li><p><strong>count</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: number of per-atom values you expect per atom
(e.g., 1 for <em>type</em>, <em>mask</em>, or <em>charge</em>; 3 for <em>x</em>, <em>v</em>, or <em>f</em>). Use
<em>count</em> = 3 with <em>image</em> if you want a single image flag unpacked into
<em>x</em>/<em>y</em>/<em>z</em> components.</p></li>
<li><p><strong>data</strong><em> [</em><em>polymorphic,dimension(:),allocatable</em><em>]</em> :: array into which to store
the data. Array <em>must</em> have the <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> attribute and be of rank 1
(i.e., <code class="docutils literal notranslate"><span class="pre">DIMENSION(:)</span></code>). If this array is already allocated, it will be
reallocated to fit the length of the incoming data. It should have type
<code class="docutils literal notranslate"><span class="pre">INTEGER(c_int)</span></code> if expecting integer data and <code class="docutils literal notranslate"><span class="pre">REAL(c_double)</span></code> if
expecting floating-point data.</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_scatter.html#_CPPv426lammps_gather_atoms_concatPvPKciiPv" title="lammps_gather_atoms_concat"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_gather_atoms_concat()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/gather_atoms_subset">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">gather_atoms_subset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">count</span></em>, <em class="sig-param"><span class="pre">ids</span></em>, <em class="sig-param"><span class="pre">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/gather_atoms_subset" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls <a class="reference internal" href="Library_scatter.html#_CPPv426lammps_gather_atoms_subsetPvPKciiiPiPv" title="lammps_gather_atoms_subset"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_gather_atoms_subset()</span></code></a> to gather the
named atom-based entity for the atoms in the array <em>ids</em> from all processors
and return it in the vector <em>data</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>This subroutine gathers data for the requested atom IDs and stores them in a
one-dimensional allocatable array. The data will be ordered by
atom ID, but there is no requirement that the IDs be consecutive. If you
wish to return a similar array for <em>all</em> the atoms, use
<a class="reference internal" href="#f/_/gather_atoms" title="f/_/gather_atoms"><code class="xref f f-func docutils literal notranslate"><span class="pre">gather_atoms()</span></code></a> or <a class="reference internal" href="#f/_/gather_atoms_concat" title="f/_/gather_atoms_concat"><code class="xref f f-func docutils literal notranslate"><span class="pre">gather_atoms_concat()</span></code></a>.</p>
<p>The <em>data</em> array will be in groups of <em>count</em> values, sorted by atom ID
in the same order as the array <em>ids</em> (e.g., if <em>name</em> is <em>x</em>, <em>count</em> = 3,
and <em>ids</em> is [100, 57, 210], then <em>data</em> might look like
[<em>x</em>(1,100), <em>x</em>(2,100), <em>x</em>(3,100), <em>x</em>(1,57), <em>x</em>(2,57),
<em>x</em>(3,57), <em>x</em>(1,210), <span class="math notranslate nohighlight">\(\dots\)</span>]; <em>ids</em> must be provided by the
user, and <em>data</em> must be of rank 1 (i.e., <code class="docutils literal notranslate"><span class="pre">DIMENSION(:)</span></code>) and have the
<code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> attribute.</p>
<p>This function is not compatible with <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong><em> [</em><em>character(len=*)</em><em>]</em> :: desired quantity (e.g., <em>x</em> or <em>mask</em>)</p></li>
<li><p><strong>count</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: number of per-atom values you expect per atom
(e.g., 1 for <em>type</em>, <em>mask</em>, or <em>charge</em>; 3 for <em>x</em>, <em>v</em>, or <em>f</em>). Use
<em>count</em> = 3 with <em>image</em> if you want a single image flag unpacked into
<em>x</em>/<em>y</em>/<em>z</em> components.</p></li>
<li><p><strong>ids</strong><em> [</em><em>integer(c_int)</em><em>,</em><em>dimension(:)</em><em>]</em> :: atom IDs corresponding to the atoms
to be gathered</p></li>
<li><p><strong>data</strong><em> [</em><em>polymorphic,dimension(:),allocatable</em><em>]</em> :: array into which to store
the data. Array <em>must</em> have the <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> attribute and be of rank 1
(i.e., <code class="docutils literal notranslate"><span class="pre">DIMENSION(:)</span></code>). If this array is already allocated, it will be
reallocated to fit the length of the incoming data. It should have type
<code class="docutils literal notranslate"><span class="pre">INTEGER(c_int)</span></code> if expecting integer data and <code class="docutils literal notranslate"><span class="pre">REAL(c_double)</span></code> if
expecting floating-point data.</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_scatter.html#_CPPv426lammps_gather_atoms_subsetPvPKciiiPiPv" title="lammps_gather_atoms_subset"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_gather_atoms_subset()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/scatter_atoms">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">scatter_atoms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/scatter_atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls <a class="reference internal" href="Library_scatter.html#_CPPv420lammps_scatter_atomsPvPKciiPv" title="lammps_scatter_atoms"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_scatter_atoms()</span></code></a> to scatter the named
atom-based entities in <em>data</em> to all processors.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>This subroutine takes data stored in a one-dimensional array supplied by the
user and scatters them to all atoms on all processors. The data must be
ordered by atom ID, with the requirement that the IDs be consecutive.
Use <a class="reference internal" href="#f/_/scatter_atoms_subset" title="f/_/scatter_atoms_subset"><code class="xref f f-func docutils literal notranslate"><span class="pre">scatter_atoms_subset()</span></code></a> to scatter data for some (or all)
atoms, in any order.</p>
<p>The <em>data</em> array needs to be ordered in groups of <em>count</em> values, sorted by
atom ID (e.g., if <em>name</em> is <em>x</em> and <em>count</em> = 3, then
<em>data</em> = [<em>x</em>(1,1), <em>x</em>(2,1), <em>x</em>(3,1), <em>x</em>(1,2), <em>x</em>(2,2),
<em>x</em>(3,2), <em>x</em>(1,3), <span class="math notranslate nohighlight">\(\dots\)</span>]); <em>data</em> must be of length <em>natoms</em>
or 3*<em>natoms</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong><em> [</em><em>character(len=*)</em><em>]</em> :: quantity to be scattered (e.g., <em>x</em> or <em>charge</em>)</p></li>
<li><p><strong>data</strong><em> [</em><em>polymorphic,dimension(:)</em><em>]</em> :: per-atom values packed in a one-dimensional array
containing the data to be scattered. This array must have length <em>natoms</em>
(e.g., for <em>type</em> or <em>charge</em>) or length <em>natoms</em><span class="math notranslate nohighlight">\({}\times 3\)</span>
(e.g., for <em>x</em> or <em>f</em>). The array <em>data</em> must be rank 1 (i.e.,
<code class="docutils literal notranslate"><span class="pre">DIMENSION(:)</span></code>) and be of type <code class="docutils literal notranslate"><span class="pre">INTEGER(c_int)</span></code> (e.g., for <em>mask</em> or
<em>type</em>) or of type <code class="docutils literal notranslate"><span class="pre">REAL(c_double)</span></code> (e.g., for <em>x</em> or <em>charge</em> or <em>f</em>).</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_scatter.html#_CPPv420lammps_scatter_atomsPvPKciiPv" title="lammps_scatter_atoms"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_scatter_atoms()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/scatter_atoms_subset">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">scatter_atoms_subset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">ids</span></em>, <em class="sig-param"><span class="pre">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/scatter_atoms_subset" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls <a class="reference internal" href="Library_scatter.html#_CPPv427lammps_scatter_atoms_subsetPvPKciiiPiPv" title="lammps_scatter_atoms_subset"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_scatter_atoms_subset()</span></code></a> to scatter the
named atom-based entities in <em>data</em> to all processors.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>This subroutine takes data stored in a one-dimensional array supplied by the
user and scatters them to a subset of atoms on all processors. The array
<em>data</em> contains data associated with atom IDs, but there is no requirement
that the IDs be consecutive, as they are provided in a separate array,
<em>ids</em>. Use <a class="reference internal" href="#f/_/scatter_atoms" title="f/_/scatter_atoms"><code class="xref f f-func docutils literal notranslate"><span class="pre">scatter_atoms()</span></code></a> to scatter data for all atoms, in order.</p>
<p>The <em>data</em> array needs to be organized in groups of 1 or 3 values,
depending on which quantity is being scattered, with the groups in the same
order as the array <em>ids</em>. For example, if you want <em>data</em> to be the array
[<em>x</em>(1,1), <em>x</em>(2,1), <em>x</em>(3,1), <em>x</em>(1,100), <em>x</em>(2,100),
<em>x</em>(3,100), <em>x</em>(1,57), <em>x</em>(2,57), <em>x</em>(3,57)], then <em>ids</em> would be
[1, 100, 57] and <em>name</em> would be <em>x</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong><em> [</em><em>character(len=*)</em><em>]</em> :: quantity to be scattered (e.g., <em>x</em> or <em>charge</em>)</p></li>
<li><p><strong>ids</strong><em> [</em><em>integer(c_int)</em><em>,</em><em>dimension(:)</em><em>]</em> :: atom IDs corresponding to the atoms
being scattered</p></li>
<li><p><strong>data</strong><em> [</em><em>polymorphic,dimension(:)</em><em>]</em> :: per-atom values packed into a
one-dimensional array containing the data to be scattered. This array must
have either the same length as <em>ids</em> (for <em>mask</em>, <em>type</em>, etc.) or three
times its length (for <em>x</em>, <em>f</em>, etc.); the array must be rank 1
and be of type <code class="docutils literal notranslate"><span class="pre">INTEGER(c_int)</span></code> (e.g., for <em>mask</em> or <em>type</em>) or of type
<code class="docutils literal notranslate"><span class="pre">REAL(c_double)</span></code> (e.g., for <em>charge</em>, <em>x</em>, or <em>f</em>).</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_scatter.html#_CPPv427lammps_scatter_atoms_subsetPvPKciiiPiPv" title="lammps_scatter_atoms_subset"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_scatter_atoms_subset()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/gather_bonds">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">gather_bonds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/gather_bonds" title="Permalink to this definition">¶</a></dt>
<dd><p>Gather type and constituent atom information for all bonds.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>This function copies the list of all bonds into an allocatable array.
The array will be filled with (bond type, bond atom 1, bond atom 2) for each
bond. The array is allocated to the right length (i.e., three times the
number of bonds). The array <em>data</em> must be of the same type as the LAMMPS
<code class="docutils literal notranslate"><span class="pre">tagint</span></code> type, which is equivalent to either <code class="docutils literal notranslate"><span class="pre">INTEGER(c_int)</span></code> or
<code class="docutils literal notranslate"><span class="pre">INTEGER(c_int64_t)</span></code>, depending on whether <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code> was used
when LAMMPS was built. If the supplied array does not match, an error will
result at run-time.</p>
<p>An example of how to use this routine is below:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">PROGRAM </span><span class="n">bonds</span>
<span class="w">  </span><span class="k">USE</span><span class="p">,</span><span class="w"> </span><span class="k">INTRINSIC</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="nb">ISO_C_BINDING</span><span class="p">,</span><span class="w"> </span><span class="k">ONLY</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">c_int</span>
<span class="kt">  </span><span class="k">USE</span><span class="p">,</span><span class="w"> </span><span class="k">INTRINSIC</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">ISO_FORTRAN_ENV</span><span class="p">,</span><span class="w"> </span><span class="k">ONLY</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">OUTPUT_UNIT</span>
<span class="w">  </span><span class="k">USE </span><span class="n">LIBLAMMPS</span>
<span class="w">  </span><span class="k">IMPLICIT NONE</span>
<span class="k">  </span><span class="kt">INTEGER</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span><span class="w"> </span><span class="k">DIMENSION</span><span class="p">(:),</span><span class="w"> </span><span class="k">ALLOCATABLE</span><span class="p">,</span><span class="w"> </span><span class="k">TARGET</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">bonds</span>
<span class="w">  </span><span class="kt">INTEGER</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span><span class="w"> </span><span class="k">DIMENSION</span><span class="p">(:,:),</span><span class="w"> </span><span class="k">POINTER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">bonds_array</span>
<span class="w">  </span><span class="k">TYPE</span><span class="p">(</span><span class="n">lammps</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">lmp</span>
<span class="w">  </span><span class="kt">INTEGER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">i</span>
<span class="w">  </span><span class="c">! other commands to initialize LAMMPS, create bonds, etc.</span>
<span class="w">  </span><span class="k">CALL </span><span class="n">lmp</span><span class="p">%</span><span class="n">gather_bonds</span><span class="p">(</span><span class="n">bonds</span><span class="p">)</span>
<span class="w">  </span><span class="n">bonds_array</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="n">SIZE</span><span class="p">(</span><span class="n">bonds</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">bonds</span>
<span class="w">  </span><span class="k">DO </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">SIZE</span><span class="p">(</span><span class="n">bonds</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span>
<span class="w">    </span><span class="k">WRITE</span><span class="p">(</span><span class="n">OUTPUT_UNIT</span><span class="p">,</span><span class="s1">&#39;(A,1X,I4,A,I4,1X,I4)&#39;</span><span class="p">)</span><span class="w"> </span><span class="s1">&#39;bond&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">bonds_array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">      </span><span class="s1">&#39;; type = &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">bonds_array</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">bonds_array</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
<span class="w">  </span><span class="k">END DO</span>
<span class="k">END PROGRAM </span><span class="n">bonds</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong><em> [</em><em>integer(kind=*),allocatable</em><em>]</em> :: array into which to copy the result. *The <code class="docutils literal notranslate"><span class="pre">KIND</span></code> parameter is
either <code class="docutils literal notranslate"><span class="pre">c_int</span></code> or, if LAMMPS was compiled with <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code>,
kind <code class="docutils literal notranslate"><span class="pre">c_int64_t</span></code>.</p>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_scatter.html#_CPPv419lammps_gather_bondsPvPv" title="lammps_gather_bonds"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_gather_bonds()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/gather_angles">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">gather_angles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/gather_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gather type and constituent atom information for all angles.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 8Feb2023.</span></p>
</div>
<p>This function copies the list of all angles into an allocatable array.
The array will be filled with (angle type, angle atom 1, angle atom 2, angle atom 3)
for each angle. The array is allocated to the right length (i.e., four times the
number of angles). The array <em>data</em> must be of the same type as the LAMMPS
<code class="docutils literal notranslate"><span class="pre">tagint</span></code> type, which is equivalent to either <code class="docutils literal notranslate"><span class="pre">INTEGER(c_int)</span></code> or
<code class="docutils literal notranslate"><span class="pre">INTEGER(c_int64_t)</span></code>, depending on whether <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code> was used
when LAMMPS was built. If the supplied array does not match, an error will
result at run-time.</p>
<p>An example of how to use this routine is below:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">PROGRAM </span><span class="n">angles</span>
<span class="w">  </span><span class="k">USE</span><span class="p">,</span><span class="w"> </span><span class="k">INTRINSIC</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="nb">ISO_C_BINDING</span><span class="p">,</span><span class="w"> </span><span class="k">ONLY</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">c_int</span>
<span class="kt">  </span><span class="k">USE</span><span class="p">,</span><span class="w"> </span><span class="k">INTRINSIC</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">ISO_FORTRAN_ENV</span><span class="p">,</span><span class="w"> </span><span class="k">ONLY</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">OUTPUT_UNIT</span>
<span class="w">  </span><span class="k">USE </span><span class="n">LIBLAMMPS</span>
<span class="w">  </span><span class="k">IMPLICIT NONE</span>
<span class="k">  </span><span class="kt">INTEGER</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span><span class="w"> </span><span class="k">DIMENSION</span><span class="p">(:),</span><span class="w"> </span><span class="k">ALLOCATABLE</span><span class="p">,</span><span class="w"> </span><span class="k">TARGET</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">angles</span>
<span class="w">  </span><span class="kt">INTEGER</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span><span class="w"> </span><span class="k">DIMENSION</span><span class="p">(:,:),</span><span class="w"> </span><span class="k">POINTER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">angles_array</span>
<span class="w">  </span><span class="k">TYPE</span><span class="p">(</span><span class="n">lammps</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">lmp</span>
<span class="w">  </span><span class="kt">INTEGER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">i</span>
<span class="w">  </span><span class="c">! other commands to initialize LAMMPS, create angles, etc.</span>
<span class="w">  </span><span class="k">CALL </span><span class="n">lmp</span><span class="p">%</span><span class="n">gather_angles</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
<span class="w">  </span><span class="n">angles_array</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="n">SIZE</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">angles</span>
<span class="w">  </span><span class="k">DO </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">SIZE</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span>
<span class="w">    </span><span class="k">WRITE</span><span class="p">(</span><span class="n">OUTPUT_UNIT</span><span class="p">,</span><span class="s1">&#39;(A,1X,I4,A,I4,1X,I4,1X,I4)&#39;</span><span class="p">)</span><span class="w"> </span><span class="s1">&#39;angle&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">angles_array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">      </span><span class="s1">&#39;; type = &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">angles_array</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">angles_array</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">angles_array</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
<span class="w">  </span><span class="k">END DO</span>
<span class="k">END PROGRAM </span><span class="n">angles</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong><em> [</em><em>integer(kind=*),allocatable</em><em>]</em> :: array into which to copy the result. *The <code class="docutils literal notranslate"><span class="pre">KIND</span></code> parameter is
either <code class="docutils literal notranslate"><span class="pre">c_int</span></code> or, if LAMMPS was compiled with <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code>,
kind <code class="docutils literal notranslate"><span class="pre">c_int64_t</span></code>.</p>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_scatter.html#_CPPv420lammps_gather_anglesPvPv" title="lammps_gather_angles"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_gather_angles()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/gather">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">gather</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">self</span></em>, <em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">count</span></em>, <em class="sig-param"><span class="pre">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/gather" title="Permalink to this definition">¶</a></dt>
<dd><p>Gather the named per-atom, per-atom fix, per-atom compute, or fix
property/atom-based entities from all processes, in order by atom ID.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 22Dec2022.</span></p>
</div>
<p>This subroutine gathers data from all processes and stores them in a
one-dimensional allocatable array. The array <em>data</em> will be
ordered by atom ID, which requires consecutive IDs (1 to <em>natoms</em>). If you
need a similar array but for non-consecutive atom IDs, see
<a class="reference internal" href="Library_scatter.html#_CPPv420lammps_gather_concatPvPKciiPv" title="lammps_gather_concat"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_gather_concat()</span></code></a>; for a similar array but for a subset of
atoms, see <a class="reference internal" href="Library_scatter.html#_CPPv420lammps_gather_subsetPvPKciiiPiPv" title="lammps_gather_subset"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_gather_subset()</span></code></a>.</p>
<p>The <em>data</em> array will be ordered in groups of <em>count</em> values, sorted by atom
ID (e.g., if <em>name</em> is <em>x</em>, then <em>data</em> is [x(1,1), x(2,1), x(3,1), x(1,2),
x(2,2), x(3,2), x(1,3), <span class="math notranslate nohighlight">\(\dots\)</span>]); <em>data</em> must be <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> and
will be allocated to length (<em>count</em><span class="math notranslate nohighlight">\({}\times{}\)</span><em>natoms</em>), as
queried by <a class="reference internal" href="#f/_/get_natoms" title="f/_/get_natoms"><code class="xref f f-func docutils literal notranslate"><span class="pre">get_natoms()</span></code></a>.</p>
<p>This function will return an error if fix or compute data are requested and
the fix or compute ID given does not have per-atom data. See the note about
re-interpreting the vector as a matrix at <a class="reference internal" href="#f/_/gather_atoms" title="f/_/gather_atoms"><code class="xref f f-subr docutils literal notranslate"><span class="pre">gather_atoms()</span></code></a>.</p>
<p>This function is not compatible with <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong><em> [</em><em>character(len=*)</em><em>]</em> :: desired quantity (e.g., “x” or “mask” for atom
properties, “f_id” for per-atom fix data, “c_id” for per-atom compute data,
“d_name” or “i_name” for fix property/atom vectors with <em>count</em> = 1,
“d2_name” or “i2_name” for fix property/atom vectors with
<em>count</em><span class="math notranslate nohighlight">\({}&gt; 1\)</span>)</p></li>
<li><p><strong>count</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: number of per-atom values (e.g., 1 for <em>type</em> or
<em>charge</em>, 3 for <em>x</em> or <em>f</em>); use <em>count</em> = 3 with <em>image</em> if you want the
image flags unpacked into (<em>x</em>,<em>y</em>,<em>z</em>) components.</p></li>
<li><p><strong>data</strong><em> [</em><em>real(c_double)</em><em>,</em><em>dimension(:),allocatable</em><em>]</em> :: array into which to store
the data. Array <em>must</em> have the <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> attribute and be of rank 1
(i.e., <code class="docutils literal notranslate"><span class="pre">DIMENSION(:)</span></code>). If this array is already allocated, it will be
reallocated to fit the length of the incoming data.</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_scatter.html#_CPPv413lammps_gatherPvPKciiPv" title="lammps_gather"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_gather()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/gather_dihedrals">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">gather_dihedrals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/gather_dihedrals" title="Permalink to this definition">¶</a></dt>
<dd><p>Gather type and constituent atom information for all dihedrals.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 8Feb2023.</span></p>
</div>
<p>This function copies the list of all dihedrals into an allocatable array.
The array will be filled with (dihedral type, dihedral atom 1, dihedral atom 2,
dihedral atom 3, dihedral atom 4) for each dihedral. The array is allocated to
the right length (i.e., five times the number of dihedrals).
The array <em>data</em> must be of the same type as the LAMMPS
<code class="docutils literal notranslate"><span class="pre">tagint</span></code> type, which is equivalent to either <code class="docutils literal notranslate"><span class="pre">INTEGER(c_int)</span></code> or
<code class="docutils literal notranslate"><span class="pre">INTEGER(c_int64_t)</span></code>, depending on whether <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code> was used
when LAMMPS was built. If the supplied array does not match, an error will
result at run-time.</p>
<p>An example of how to use this routine is below:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">PROGRAM </span><span class="n">dihedrals</span>
<span class="w">  </span><span class="k">USE</span><span class="p">,</span><span class="w"> </span><span class="k">INTRINSIC</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="nb">ISO_C_BINDING</span><span class="p">,</span><span class="w"> </span><span class="k">ONLY</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">c_int</span>
<span class="kt">  </span><span class="k">USE</span><span class="p">,</span><span class="w"> </span><span class="k">INTRINSIC</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">ISO_FORTRAN_ENV</span><span class="p">,</span><span class="w"> </span><span class="k">ONLY</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">OUTPUT_UNIT</span>
<span class="w">  </span><span class="k">USE </span><span class="n">LIBLAMMPS</span>
<span class="w">  </span><span class="k">IMPLICIT NONE</span>
<span class="k">  </span><span class="kt">INTEGER</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span><span class="w"> </span><span class="k">DIMENSION</span><span class="p">(:),</span><span class="w"> </span><span class="k">ALLOCATABLE</span><span class="p">,</span><span class="w"> </span><span class="k">TARGET</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">dihedrals</span>
<span class="w">  </span><span class="kt">INTEGER</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span><span class="w"> </span><span class="k">DIMENSION</span><span class="p">(:,:),</span><span class="w"> </span><span class="k">POINTER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">dihedrals_array</span>
<span class="w">  </span><span class="k">TYPE</span><span class="p">(</span><span class="n">lammps</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">lmp</span>
<span class="w">  </span><span class="kt">INTEGER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">i</span>
<span class="w">  </span><span class="c">! other commands to initialize LAMMPS, create dihedrals, etc.</span>
<span class="w">  </span><span class="k">CALL </span><span class="n">lmp</span><span class="p">%</span><span class="n">gather_dihedrals</span><span class="p">(</span><span class="n">dihedrals</span><span class="p">)</span>
<span class="w">  </span><span class="n">dihedrals_array</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="n">SIZE</span><span class="p">(</span><span class="n">dihedrals</span><span class="p">)</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">dihedrals</span>
<span class="w">  </span><span class="k">DO </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">SIZE</span><span class="p">(</span><span class="n">dihedrals</span><span class="p">)</span><span class="o">/</span><span class="mi">5</span>
<span class="w">    </span><span class="k">WRITE</span><span class="p">(</span><span class="n">OUTPUT_UNIT</span><span class="p">,</span><span class="s1">&#39;(A,1X,I4,A,I4,1X,I4,1X,I4,1X,I4)&#39;</span><span class="p">)</span><span class="w"> </span><span class="s1">&#39;dihedral&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">dihedrals_array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">      </span><span class="s1">&#39;; type = &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">dihedrals_array</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">dihedrals_array</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">dihedrals_array</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">dihedrals_array</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
<span class="w">  </span><span class="k">END DO</span>
<span class="k">END PROGRAM </span><span class="n">dihedrals</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong><em> [</em><em>integer(kind=*),allocatable</em><em>]</em> :: array into which to copy the result. *The <code class="docutils literal notranslate"><span class="pre">KIND</span></code> parameter is
either <code class="docutils literal notranslate"><span class="pre">c_int</span></code> or, if LAMMPS was compiled with <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code>,
kind <code class="docutils literal notranslate"><span class="pre">c_int64_t</span></code>.</p>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_scatter.html#_CPPv423lammps_gather_dihedralsPvPv" title="lammps_gather_dihedrals"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_gather_dihedrals()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/gather_impropers">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">gather_impropers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/gather_impropers" title="Permalink to this definition">¶</a></dt>
<dd><p>Gather type and constituent atom information for all impropers.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 8Feb2023.</span></p>
</div>
<p>This function copies the list of all impropers into an allocatable array.
The array will be filled with (improper type, improper atom 1, improper atom 2,
improper atom 3, improper atom 4) for each improper. The array is allocated to
the right length (i.e., five times the number of impropers).
The array <em>data</em> must be of the same type as the LAMMPS
<code class="docutils literal notranslate"><span class="pre">tagint</span></code> type, which is equivalent to either <code class="docutils literal notranslate"><span class="pre">INTEGER(c_int)</span></code> or
<code class="docutils literal notranslate"><span class="pre">INTEGER(c_int64_t)</span></code>, depending on whether <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code> was used
when LAMMPS was built. If the supplied array does not match, an error will
result at run-time.</p>
<p>An example of how to use this routine is below:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">PROGRAM </span><span class="n">impropers</span>
<span class="w">  </span><span class="k">USE</span><span class="p">,</span><span class="w"> </span><span class="k">INTRINSIC</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="nb">ISO_C_BINDING</span><span class="p">,</span><span class="w"> </span><span class="k">ONLY</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">c_int</span>
<span class="kt">  </span><span class="k">USE</span><span class="p">,</span><span class="w"> </span><span class="k">INTRINSIC</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">ISO_FORTRAN_ENV</span><span class="p">,</span><span class="w"> </span><span class="k">ONLY</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">OUTPUT_UNIT</span>
<span class="w">  </span><span class="k">USE </span><span class="n">LIBLAMMPS</span>
<span class="w">  </span><span class="k">IMPLICIT NONE</span>
<span class="k">  </span><span class="kt">INTEGER</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span><span class="w"> </span><span class="k">DIMENSION</span><span class="p">(:),</span><span class="w"> </span><span class="k">ALLOCATABLE</span><span class="p">,</span><span class="w"> </span><span class="k">TARGET</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">impropers</span>
<span class="w">  </span><span class="kt">INTEGER</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span><span class="w"> </span><span class="k">DIMENSION</span><span class="p">(:,:),</span><span class="w"> </span><span class="k">POINTER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">impropers_array</span>
<span class="w">  </span><span class="k">TYPE</span><span class="p">(</span><span class="n">lammps</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">lmp</span>
<span class="w">  </span><span class="kt">INTEGER</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">i</span>
<span class="w">  </span><span class="c">! other commands to initialize LAMMPS, create impropers, etc.</span>
<span class="w">  </span><span class="k">CALL </span><span class="n">lmp</span><span class="p">%</span><span class="n">gather_impropers</span><span class="p">(</span><span class="n">impropers</span><span class="p">)</span>
<span class="w">  </span><span class="n">impropers_array</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="n">SIZE</span><span class="p">(</span><span class="n">impropers</span><span class="p">)</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">impropers</span>
<span class="w">  </span><span class="k">DO </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">SIZE</span><span class="p">(</span><span class="n">impropers</span><span class="p">)</span><span class="o">/</span><span class="mi">5</span>
<span class="w">    </span><span class="k">WRITE</span><span class="p">(</span><span class="n">OUTPUT_UNIT</span><span class="p">,</span><span class="s1">&#39;(A,1X,I4,A,I4,1X,I4,1X,I4,1X,I4)&#39;</span><span class="p">)</span><span class="w"> </span><span class="s1">&#39;improper&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">impropers_array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="p">&amp;</span>
<span class="w">      </span><span class="s1">&#39;; type = &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">impropers_array</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">impropers_array</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">impropers_array</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">impropers_array</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
<span class="w">  </span><span class="k">END DO</span>
<span class="k">END PROGRAM </span><span class="n">impropers</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong><em> [</em><em>integer(kind=*),allocatable</em><em>]</em> :: array into which to copy the result. *The <code class="docutils literal notranslate"><span class="pre">KIND</span></code> parameter is
either <code class="docutils literal notranslate"><span class="pre">c_int</span></code> or, if LAMMPS was compiled with <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code>,
kind <code class="docutils literal notranslate"><span class="pre">c_int64_t</span></code>.</p>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_scatter.html#_CPPv423lammps_gather_impropersPvPv" title="lammps_gather_impropers"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_gather_impropers()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/gather_concat">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">gather_concat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">self</span></em>, <em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">count</span></em>, <em class="sig-param"><span class="pre">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/gather_concat" title="Permalink to this definition">¶</a></dt>
<dd><p>Gather the named per-atom, per-atom fix, per-atom compute, or fix
property/atom-based entities from all processes, unordered.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 22Dec2022.</span></p>
</div>
<p>This subroutine gathers data for all atoms and stores them in a
one-dimensional allocatable array. The data will be a
concatenation of chunks from each processor’s owned atoms, in whatever order
the atoms are in on each processor. This process has no requirement that the
atom IDs be consecutive. If you need the ID of each atom, you can do another
call to either <a class="reference internal" href="#f/_/gather_atoms_concat" title="f/_/gather_atoms_concat"><code class="xref f f-subr docutils literal notranslate"><span class="pre">gather_atoms_concat()</span></code></a> or <a class="reference internal" href="#f/_/gather_concat" title="f/_/gather_concat"><code class="xref f f-subr docutils literal notranslate"><span class="pre">gather_concat()</span></code></a> with
<em>name</em> set to <code class="docutils literal notranslate"><span class="pre">id</span></code>. If you have consecutive IDs and want the data to be in
order, use <a class="reference internal" href="#f/_/gather" title="f/_/gather"><code class="xref f f-subr docutils literal notranslate"><span class="pre">gather()</span></code></a>; for a similar array but for a subset of
atoms, use <a class="reference internal" href="#f/_/gather_subset" title="f/_/gather_subset"><code class="xref f f-subr docutils literal notranslate"><span class="pre">gather_subset()</span></code></a>.</p>
<p>The <em>data</em> array will be in groups of <em>count</em> values, with <em>natoms</em> groups
total, but not in order by atom ID (e.g., if <em>name</em> is <em>x</em> and <em>count</em> is 3,
then <em>data</em> might be something like [x(1,11), x(2,11), x(3,11), x(1,3),
x(2,3), x(3,3), x(1,5), <span class="math notranslate nohighlight">\(\dots\)</span>]); <em>data</em> must be <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> and
will be allocated to length (<em>count</em> <span class="math notranslate nohighlight">\(\times\)</span> <em>natoms</em>), as queried by
<a class="reference internal" href="#f/_/get_natoms" title="f/_/get_natoms"><code class="xref f f-func docutils literal notranslate"><span class="pre">get_natoms()</span></code></a>.</p>
<p>This function is not compatible with <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong><em> [</em><em>character(len=*)</em><em>]</em> :: desired quantity (e.g., “x” or “mask” for atom
properties, “f_id” for per-atom fix data, “c_id” for per-atom compute data,
“d_name” or “i_name” for fix property/atom vectors with <em>count</em> = 1,
“d2_name” or “i2_name” for fix property/atom vectors with
<em>count</em><span class="math notranslate nohighlight">\({}&gt; 1\)</span>)</p></li>
<li><p><strong>count</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: number of per-atom values you expect per atom
(e.g., 1 for <em>type</em>, <em>mask</em>, or <em>charge</em>; 3 for <em>x</em>, <em>v</em>, or <em>f</em>). Use
<em>count</em> = 3 with <em>image</em> if you want a single image flag unpacked into
<em>x</em>/<em>y</em>/<em>z</em> components.</p></li>
<li><p><strong>data</strong><em> [</em><em>polymorphic,dimension(:),allocatable</em><em>]</em> :: array into which to store
the data. Array <em>must</em> have the <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> attribute and be of rank 1
(i.e., <code class="docutils literal notranslate"><span class="pre">DIMENSION(:)</span></code>). If this array is already allocated, it will be
reallocated to fit the length of the incoming data. It should have type
<code class="docutils literal notranslate"><span class="pre">INTEGER(c_int)</span></code> if expecting integer data and <code class="docutils literal notranslate"><span class="pre">REAL(c_double)</span></code> if
expecting floating-point data.</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_scatter.html#_CPPv420lammps_gather_concatPvPKciiPv" title="lammps_gather_concat"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_gather_concat()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/gather_subset">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">gather_subset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">count</span></em>, <em class="sig-param"><span class="pre">ids</span></em>, <em class="sig-param"><span class="pre">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/gather_subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Gather the named per-atom, per-atom fix, per-atom compute, or fix
property/atom-based entities from all processes for a subset of atoms.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 22Dec2022.</span></p>
</div>
<p>This subroutine gathers data for the requested atom IDs and stores them in a
one-dimensional allocatable array. The data will be ordered by atom ID, but
there is no requirement that the IDs be consecutive. If you wish to return a
similar array for <em>all</em> the atoms, use <a class="reference internal" href="#f/_/gather" title="f/_/gather"><code class="xref f f-subr docutils literal notranslate"><span class="pre">gather()</span></code></a> or
<a class="reference internal" href="#f/_/gather_concat" title="f/_/gather_concat"><code class="xref f f-subr docutils literal notranslate"><span class="pre">gather_concat()</span></code></a>.</p>
<p>The <em>data</em> array will be in groups of <em>count</em> values, sorted by atom ID in
the same order as the array <em>ids</em> (e.g., if <em>name</em> is <em>x</em>, <em>count</em> = 3, and
<em>ids</em> is [100, 57, 210], then <em>data</em> might look like [<em>x</em>(1,100),
<em>x</em>(2,100), <em>x</em>(3,100), <em>x</em>(1,57), <em>x</em>(2,57), <em>x</em>(3,57),
<em>x</em>(1,210), <span class="math notranslate nohighlight">\(\dots\)</span>]); <em>ids</em> must be provided by the user, and
<em>data</em> must have the <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> attribute and be of rank 1 (i.e.,
<code class="docutils literal notranslate"><span class="pre">DIMENSION(:)</span></code>). If <em>data</em> is already allocated, it will be reallocated to
fit the length of the incoming data.</p>
<p>This function is not compatible with <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong><em> [</em><em>character(len=*)</em><em>]</em> :: quantity to be scattered</p></li>
<li><p><strong>ids</strong><em> [</em><em>integer(c_int)</em><em>,</em><em>dimension(:)</em><em>]</em> :: atom IDs corresponding to the atoms
being scattered (e.g., “x” or “f” for atom properties, “f_id” for per-atom
fix data, “c_id” for per-atom compute data, “d_name” or “i_name” for fix
property/atom vectors with <em>count</em> = 1, “d2_name” or “i2_name” for fix
property/atom vectors with <em>count</em><span class="math notranslate nohighlight">\({} &gt; 1\)</span>)</p></li>
<li><p><strong>count</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: number of per-atom values you expect per atom
(e.g., 1 for <em>type</em>, <em>mask</em>, or <em>charge</em>; 3 for <em>x</em>, <em>v</em>, or <em>f</em>). Use
<em>count</em> = 3 with <em>image</em> if you want a single image flag unpacked into
<em>x</em>/<em>y</em>/<em>z</em> components.</p></li>
<li><p><strong>data</strong><em> [</em><em>polymorphic,dimension(:),allocatable</em><em>]</em> :: per-atom values packed into a one-dimensional array containing the
data to be scattered. This array must have the <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> attribute
and will be allocated either to the same length as <em>ids</em>
(for <em>mask</em>, <em>type</em>, etc.) or to three times its length (for <em>x</em>, <em>f</em>,
etc.); the array must be rank 1 and be of type <code class="docutils literal notranslate"><span class="pre">INTEGER(c_int)</span></code> (e.g.,
for <em>mask</em> or <em>type</em>) or of type <code class="docutils literal notranslate"><span class="pre">REAL(c_double)</span></code> (e.g., for <em>charge</em>,
<em>x</em>, or <em>f</em>).</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_scatter.html#_CPPv420lammps_gather_subsetPvPKciiiPiPv" title="lammps_gather_subset"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_gather_subset()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/scatter">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">scatter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/scatter" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls <a class="reference internal" href="Library_scatter.html#_CPPv414lammps_scatterPvPKciiPv" title="lammps_scatter"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_scatter()</span></code></a> to scatter the named
per-atom, per-atom fix, per-atom compute, or fix property/atom-based entity
in <em>data</em> to all processes.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 22Dec2022.</span></p>
</div>
<p>This subroutine takes data stored in a one-dimensional array supplied by the
user and scatters them to all atoms on all processes. The data must be
ordered by atom ID, with the requirement that the IDs be consecutive. Use
<a class="reference internal" href="#f/_/scatter_subset" title="f/_/scatter_subset"><code class="xref f f-subr docutils literal notranslate"><span class="pre">scatter_subset()</span></code></a> to scatter data for some (or all) atoms, unordered.</p>
<p>The <em>data</em> array needs to be ordered in groups of <em>count</em> values, sorted by
atom ID (e.g., if <em>name</em> is <em>x</em> and <em>count</em> = 3, then <em>data</em> = [<em>x</em>(1,1),
<em>x</em>(2,1), <em>x</em>(3,1), <em>x</em>(1,2), <em>x</em>(2,2), <em>x</em>(3,2), <em>x</em>(1,3),
<span class="math notranslate nohighlight">\(\dots\)</span>]); <em>data</em> must be of length (<em>count</em> <span class="math notranslate nohighlight">\(\times\)</span> <em>natoms</em>).</p>
<p>This function is not compatible with <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong><em> [</em><em>character(len=*)</em><em>]</em> :: desired quantity (e.g., “x” or “f” for atom
properties, “f_id” for per-atom fix data, “c_id” for per-atom compute data,
“d_name” or “i_name” for fix property/atom vectors with <em>count</em> = 1,
“d2_name” or “i2_name” for fix property/atom vectors with <em>count</em><span class="math notranslate nohighlight">\({} &gt; 1\)</span>)</p></li>
<li><p><strong>data</strong><em> [</em><em>polymorphic,dimension(:)</em><em>]</em> :: per-atom values packed in a one-dimensional array; <em>data</em> should be
of type <code class="docutils literal notranslate"><span class="pre">INTEGER(c_int)</span></code> or <code class="docutils literal notranslate"><span class="pre">REAL(c_double)</span></code>, depending on the type of
data being scattered, and be of rank 1 (i.e., <code class="docutils literal notranslate"><span class="pre">DIMENSION(:)</span></code>).</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_scatter.html#_CPPv414lammps_scatterPvPKciiPv" title="lammps_scatter"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_scatter()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/scatter_subset">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">scatter_subset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">ids</span></em>, <em class="sig-param"><span class="pre">data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/scatter_subset" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls <a class="reference internal" href="Library_scatter.html#_CPPv421lammps_scatter_subsetPvPKciiiPiPv" title="lammps_scatter_subset"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_scatter_subset()</span></code></a> to scatter the named
per-atom, per-atom fix, per-atom compute, or fix property/atom-based
entities in <em>data</em> from a subset of atoms to all processes.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 22Dec2022.</span></p>
</div>
<p>This subroutine takes data stored in a one-dimensional array supplied by the
user and scatters them to a subset of atoms on all processes. The array
<em>data</em> contains data associated with atom IDs, but there is no requirement
that the IDs be consecutive, as they are provided in a separate array.
Use <a class="reference internal" href="#f/_/scatter" title="f/_/scatter"><code class="xref f f-subr docutils literal notranslate"><span class="pre">scatter()</span></code></a> to scatter data for all atoms, in order.</p>
<p>The <em>data</em> array needs to be organized in groups of <em>count</em> values, with the
groups in the same order as the array <em>ids</em>. For example, if you want <em>data</em>
to be the array [x(1,1), x(2,1), x(3,1), x(1,100), x(2,100), x(3,100),
x(1,57), x(2,57), x(3,57)], then <em>count</em> = 3 and <em>ids</em> = [1, 100, 57].</p>
<p>This function is not compatible with <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong><em> [</em><em>character(len=*)</em><em>]</em> :: desired quantity (e.g., “x” or “mask” for atom
properties, “f_id” for per-atom fix data, “c_id” for per-atom compute data,
“d_name” or “i_name” for fix property/atom vectors with <em>count</em> = 1,
“d2_name” or “i2_name” for fix property/atom vectors with
<em>count</em><span class="math notranslate nohighlight">\({}&gt; 1\)</span>)</p></li>
<li><p><strong>ids</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: list of atom IDs to scatter data for</p></li>
<li><p><strong>data</strong><em> [</em><em>polymorphic </em><em>,</em><em>dimension(:)</em><em>]</em> :: per-atom values packed in a
one-dimensional array of length <em>size(ids)</em> * <em>count</em>.</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_scatter.html#_CPPv421lammps_scatter_subsetPvPKciiiPiPv" title="lammps_scatter_subset"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_scatter_subset()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/create_atoms">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">create_atoms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">[id,]</span> <span class="pre">type,</span> <span class="pre">x,</span> <span class="pre">[v,]</span> <span class="pre">[image,]</span> <span class="pre">[bexpand]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/create_atoms" title="Permalink to this definition">¶</a></dt>
<dd><p>This method calls <a class="reference internal" href="Library_scatter.html#_CPPv419lammps_create_atomsPviPKiPKiPKdPKdPKii" title="lammps_create_atoms"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_create_atoms()</span></code></a> to create additional atoms
from a given list of coordinates and a list of atom types. Additionally,
the atom IDs, velocities, and image flags may be provided.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong><em> [</em><em>integer(c_int)</em><em>,</em><em>dimension(N)</em><em>]</em> :: vector of <span class="math notranslate nohighlight">\(N\)</span> atom types
(required/see note below)</p></li>
<li><p><strong>x</strong><em> [</em><em>real(c_double)</em><em>,</em><em>dimension(3N)</em><em>]</em> :: vector of <span class="math notranslate nohighlight">\(3N\ x/y/z\)</span> positions
of the new atoms, arranged as <span class="math notranslate nohighlight">\([x_1,y_1,z_1,x_2,y_2,\dotsc]\)</span>
(required/see note below)</p></li>
</ul>
</dd>
<dt class="field-even">Options<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>id</strong><em> [</em><em>integer(kind=*)</em><em>,</em><em>dimension(N),optional</em><em>]</em> :: vector of <span class="math notranslate nohighlight">\(N\)</span> atom
IDs; if absent, LAMMPS will generate them for you. *The <code class="docutils literal notranslate"><span class="pre">KIND</span></code> parameter
should be <code class="docutils literal notranslate"><span class="pre">c_int</span></code> unless LAMMPS was compiled with <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code>, in
which case it should be <code class="docutils literal notranslate"><span class="pre">c_int64_t</span></code>.</p></li>
<li><p><strong>v</strong><em> [</em><em>real(c_double)</em><em>,</em><em>dimension(3N),optional</em><em>]</em> :: vector of <span class="math notranslate nohighlight">\(3N\)</span>
<em>x</em>/<em>y</em>/<em>z</em> velocities of the new atoms, arranged as
<span class="math notranslate nohighlight">\([v_{1,x},v_{1,y},v_{1,z},v_{2,x}, \dotsc]\)</span>; if absent, they will be
set to zero</p></li>
<li><p><strong>image</strong><em> [</em><em>integer(kind=*)</em><em>,</em><em>dimension(N),optional</em><em>]</em> :: vector of <span class="math notranslate nohighlight">\(N\)</span> image
flags; if absent, they are set to zero. *The <code class="docutils literal notranslate"><span class="pre">KIND</span></code> parameter should be
<code class="docutils literal notranslate"><span class="pre">c_int</span></code> unless LAMMPS was compiled with <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code>, in which
case it should be <code class="docutils literal notranslate"><span class="pre">c_int64_t</span></code>. See note below.</p></li>
<li><p><strong>bexpand</strong><em> [</em><em>logical,optional</em><em>]</em> :: if <code class="docutils literal notranslate"><span class="pre">.TRUE.</span></code>, atoms outside of shrink-wrap boundaries
will be created, not dropped, and the box dimensions will be extended.
Default is <code class="docutils literal notranslate"><span class="pre">.FALSE.</span></code></p></li>
</ul>
</dd>
<dt class="field-odd">Call to<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="Library_scatter.html#_CPPv419lammps_create_atomsPviPKiPKiPKdPKdPKii" title="lammps_create_atoms"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_create_atoms()</span></code></a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <em>type</em> and <em>x</em> arguments are required, but they are declared
<code class="docutils literal notranslate"><span class="pre">OPTIONAL</span></code> in the module because making them mandatory would require
<em>id</em> to be present as well. To have LAMMPS generate the ids for you,
use a call something like</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="n">lmp</span><span class="p">%</span><span class="n">create_atoms</span><span class="p">(</span><span class="k">type</span><span class="o">=</span><span class="n">new_types</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="o">=</span><span class="n">new_xs</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When LAMMPS has been compiled with <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code>, it is not
possible to include the <em>image</em> parameter but omit the <em>id</em> parameter.
Either <em>id</em> must be present, or both <em>id</em> and <em>image</em> must be absent.
This is required because having all arguments be optional in both
generic functions creates an ambiguous interface. This limitation does
not exist if LAMMPS was not compiled with <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code>.</p>
</div>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/find_pair_neighlist">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">find_pair_neighlist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">style[,</span> <span class="pre">exact][,</span> <span class="pre">nsub][,</span> <span class="pre">reqid]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/find_pair_neighlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Find index of a neighbor list requested by a pair style.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>This function determines which of the available neighbor lists for pair
styles matches the given conditions.  It first matches the style name.
If <em>exact</em> is <code class="docutils literal notranslate"><span class="pre">.TRUE.</span></code>, the name must match exactly; if <code class="docutils literal notranslate"><span class="pre">.FALSE.</span></code>, a
regular expression or sub-string match is done.  If the pair style is
<em>hybrid</em> or <em>hybrid/overlay</em>, the style is matched against the sub-styles
instead. If the same pair style is used multiple times as a sub-style, the
<em>nsub</em> argument must be <span class="math notranslate nohighlight">\(&gt; 0\)</span>; this argument represents the <em>n</em>th
instance of the sub-style (same as for the <a class="reference internal" href="pair_coeff.html"><span class="doc">pair_coeff</span></a>
command, for example). In that case, <em>nsub</em><span class="math notranslate nohighlight">\({} = 0\)</span> will not
produce a match, and the function will return <span class="math notranslate nohighlight">\(-1\)</span>.</p>
<p>The final condition to be checked is the request ID (<em>reqid</em>). This
will usually be zero, but some pair styles request multiple neighbor
lists and set the request ID to a value greater than zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>style</strong><em> [</em><em>character(len=*)</em><em>]</em> :: String used to search for pair style instance.</p>
</dd>
<dt class="field-even">Options<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>exact</strong><em> [</em><em>logical,optional</em><em>]</em> :: Flag to control whether style should match exactly or only a
regular expression/sub-string match is applied. Default: <code class="docutils literal notranslate"><span class="pre">.TRUE.</span></code>.</p></li>
<li><p><strong>nsub</strong><em> [</em><em>integer(c_int)</em><em>,</em><em>optional</em><em>]</em> :: Match <em>nsub</em>th hybrid sub-style
instance of the same style. Default: 0.</p></li>
<li><p><strong>reqid</strong><em> [</em><em>integer(c_int)</em><em>,</em><em>optional</em><em>]</em> :: Request ID to identify the neighbor list
in case there are multiple requests from the same pair style instance.
Default: 0.</p></li>
</ul>
</dd>
<dt class="field-odd">Call to<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="Library_neighbor.html#_CPPv426lammps_find_pair_neighlistPvPKciii" title="lammps_find_pair_neighlist"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_find_pair_neighlist()</span></code></a></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: Neighbor list index if found, otherwise
<span class="math notranslate nohighlight">\(-1\)</span>.</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/find_fix_neighlist">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">find_fix_neighlist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">id</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">reqid</span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#f/_/find_fix_neighlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Find index of a neighbor list requested by a fix.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>The neighbor list request from a fix is identified by the fix ID and the
request ID. The request ID is typically zero, but will be <span class="math notranslate nohighlight">\(&gt;0\)</span> for
fixes with multiple neighbor list requests.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>id</strong><em> [</em><em>character(len=*)</em><em>]</em> :: Identifier of fix instance</p>
</dd>
<dt class="field-even">Options<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>reqid</strong><em> [</em><em>integer(c_int)</em><em>,</em><em>optional</em><em>]</em> :: request ID to identify the neighbor list
in cases in which there are multiple requests from the same fix.
Default: 0.</p>
</dd>
<dt class="field-odd">Call to<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="Library_neighbor.html#_CPPv425lammps_find_fix_neighlistPvPKci" title="lammps_find_fix_neighlist"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_find_fix_neighlist()</span></code></a></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: neighbor list index if found, otherwise <span class="math notranslate nohighlight">\(-1\)</span></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/find_compute_neighlist">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">find_compute_neighlist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">id</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">reqid</span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#f/_/find_compute_neighlist" title="Permalink to this definition">¶</a></dt>
<dd><p>Find index of a neighbor list requested by a compute.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>The neighbor list request from a compute is identified by the compute ID and
the request ID.  The request ID is typically zero, but will be <span class="math notranslate nohighlight">\(&gt; 0\)</span>
in case a compute has multiple neighbor list requests.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>id</strong><em> [</em><em>character(len=*)</em><em>]</em> :: Identifier of compute instance.</p>
</dd>
<dt class="field-even">Options<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>reqid</strong><em> [</em><em>integer(c_int)</em><em>,</em><em>optional</em><em>]</em> :: request ID to identify the neighbor list
in cases in which there are multiple requests from the same compute.
Default: 0.</p>
</dd>
<dt class="field-odd">Call to<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="Library_neighbor.html#_CPPv429lammps_find_compute_neighlistPvPKci" title="lammps_find_compute_neighlist"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_find_compute_neighlist()</span></code></a></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: neighbor list index if found, otherwise <span class="math notranslate nohighlight">\(-1\)</span>.</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/neighlist_num_elements">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">neighlist_num_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">idx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/neighlist_num_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of entries in the neighbor list with the given index.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>idx</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: neighbor list index</p>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_neighbor.html#_CPPv429lammps_neighlist_num_elementsPvi" title="lammps_neighlist_num_elements"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_neighlist_num_elements()</span></code></a> <a class="reference internal" href="Library_neighbor.html#_CPPv429lammps_neighlist_num_elementsPvi" title="lammps_neighlist_num_elements"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_neighlist_num_elements()</span></code></a></p>
</dd>
<dt class="field-odd">Return<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>inum</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: number of entries in neighbor list, or <span class="math notranslate nohighlight">\(-1\)</span> if <em>idx</em> is not
a valid index.</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/neighlist_element_neighbors">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">neighlist_element_neighbors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">idx</span></em>, <em class="sig-param"><span class="pre">element</span></em>, <em class="sig-param"><span class="pre">iatom</span></em>, <em class="sig-param"><span class="pre">neighbors</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/neighlist_element_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return atom local index, number of neighbors, and array of neighbor local
atom indices of a neighbor list entry.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>idx</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: index of this neighbor list in the list of all
neighbor lists</p></li>
<li><p><strong>element</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: index of this neighbor list entry</p></li>
<li><p><strong>iatom</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: local atom index (i.e., in the range
[1,nlocal+nghost]; -1 if invalid or element value</p></li>
<li><p><strong>neighbors</strong><em> [</em><em>integer(c_int)</em><em>,</em><em>dimension(:),pointer</em><em>]</em> :: pointer to an array of
neighboring atom local indices</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_neighbor.html#_CPPv434lammps_neighlist_element_neighborsPviiPiPiPPi" title="lammps_neighlist_element_neighbors"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_neighlist_element_neighbors()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/version">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">version</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#f/_/version" title="Permalink to this definition">¶</a></dt>
<dd><p>This method returns the numeric LAMMPS version like
<a class="reference internal" href="Library_config.html#_CPPv414lammps_versionPv" title="lammps_version"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_version()</span></code></a> does.</p>
<dl class="field-list simple">
<dt class="field-odd">Call to<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="Library_config.html#_CPPv414lammps_versionPv" title="lammps_version"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_version()</span></code></a></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>version</strong><em> [</em><em>integer</em><em>]</em> :: LAMMPS version</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/get_os_info">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">get_os_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">buffer</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/get_os_info" title="Permalink to this definition">¶</a></dt>
<dd><p>This function can be used to retrieve detailed information about the hosting
operating system and compiler/runtime environment.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>A suitable buffer has to be provided. The assembled text will be truncated
so as not to overflow this buffer. The string is typically a few hundred
bytes long.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>buffer</strong><em> [</em><em>character(len=*)</em><em>]</em> :: string that will house the information.</p>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_config.html#_CPPv418lammps_get_os_infoPci" title="lammps_get_os_info"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_get_os_info()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/config_has_mpi_support">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">config_has_mpi_support</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#f/_/config_has_mpi_support" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to query whether LAMMPS was compiled with a real MPI
library or in serial.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Call to<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="Library_config.html#_CPPv429lammps_config_has_mpi_supportv" title="lammps_config_has_mpi_support"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_config_has_mpi_support()</span></code></a></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>has_mpi</strong><em> [</em><em>logical</em><em>]</em> :: <code class="docutils literal notranslate"><span class="pre">.FALSE.</span></code> when compiled with STUBS, <code class="docutils literal notranslate"><span class="pre">.TRUE.</span></code> if
complied with MPI.</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/config_has_gzip_support">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">config_has_gzip_support</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#f/_/config_has_gzip_support" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the LAMMPS library supports reading or writing compressed
files via a pipe to gzip or similar compression programs.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>Several LAMMPS commands (e.g., <a class="reference internal" href="read_data.html"><span class="doc">read_data command</span></a>, <a class="reference internal" href="write_data.html"><span class="doc">write_data command</span></a>,
<a class="reference internal" href="dump.html"><span class="doc">dump styles atom, custom, and xyz</span></a>) support reading and writing
compressed files via creating a pipe to the <code class="docutils literal notranslate"><span class="pre">gzip</span></code> program.  This function
checks whether this feature was <a class="reference internal" href="Build_settings.html#gzip"><span class="std std-ref">enabled at compile time</span></a>.
It does <strong>not</strong> check whether <code class="docutils literal notranslate"><span class="pre">gzip</span></code> or any other supported compression
programs themselves are installed and usable.</p>
<dl class="field-list simple">
<dt class="field-odd">Call to<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="Library_config.html#_CPPv430lammps_config_has_gzip_supportv" title="lammps_config_has_gzip_support"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_config_has_gzip_support()</span></code></a></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>has_gzip</strong><em> [</em><em>logical</em><em>]</em></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/config_has_png_support">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">config_has_png_support</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#f/_/config_has_png_support" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the LAMMPS library supports writing PNG format images.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>The LAMMPS <a class="reference internal" href="dump_image.html"><span class="doc">dump style image</span></a> supports writing multiple
image file formats.  Most of them, however, need support from an external
library, and using that has to be <a class="reference internal" href="Build_settings.html#graphics"><span class="std std-ref">enabled at compile time</span></a>.
This function checks whether support for the <a class="reference external" href="https://en.wikipedia.org/wiki/Portable_Network_Graphics">PNG image file format</a> is available
in the current LAMMPS library.</p>
<dl class="field-list simple">
<dt class="field-odd">Call to<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="Library_config.html#_CPPv429lammps_config_has_png_supportv" title="lammps_config_has_png_support"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_config_has_png_support()</span></code></a></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>has_png</strong><em> [</em><em>logical</em><em>]</em></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/config_has_jpeg_support">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">config_has_jpeg_support</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#f/_/config_has_jpeg_support" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the LAMMPS library supports writing JPEG format images.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>The LAMMPS <a class="reference internal" href="dump_image.html"><span class="doc">dump style image</span></a> supports writing multiple
image file formats.  Most of them, however, need support from an external
library, and using that has to be <a class="reference internal" href="Build_settings.html#graphics"><span class="std std-ref">enabled at compile time</span></a>.
This function checks whether support for the <a class="reference external" href="https://jpeg.org/jpeg/">JPEG image file format</a> is available in the current LAMMPS library.</p>
<dl class="field-list simple">
<dt class="field-odd">Call to<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="Library_config.html#_CPPv430lammps_config_has_jpeg_supportv" title="lammps_config_has_jpeg_support"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_config_has_jpeg_support()</span></code></a></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>has_jpeg</strong><em> [</em><em>logical</em><em>]</em></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/config_has_ffmpeg_support">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">config_has_ffmpeg_support</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#f/_/config_has_ffmpeg_support" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the LAMMPS library supports creating movie files via a pipe to
ffmpeg.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>The LAMMPS <a class="reference internal" href="dump_image.html"><span class="doc">dump style movie</span></a> supports generating movies
from images on-the-fly via creating a pipe to the
<a class="reference external" href="https://ffmpeg.org/ffmpeg/">ffmpeg</a> program.
This function checks whether this feature was
<a class="reference internal" href="Build_settings.html#graphics"><span class="std std-ref">enabled at compile time</span></a>.
It does <strong>not</strong> check whether the <code class="docutils literal notranslate"><span class="pre">ffmpeg</span></code> itself is installed and usable.</p>
<dl class="field-list simple">
<dt class="field-odd">Call to<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="Library_config.html#_CPPv432lammps_config_has_ffmpeg_supportv" title="lammps_config_has_ffmpeg_support"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_config_has_ffmpeg_support()</span></code></a></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>has_ffmpeg</strong><em> [</em><em>logical</em><em>]</em></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/config_has_exceptions">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">config_has_exceptions</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#f/_/config_has_exceptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether LAMMPS errors will throw C++ exceptions.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>In case of an error, LAMMPS will either abort or throw a C++ exception.
The latter has to be <a class="reference internal" href="Build_settings.html#exceptions"><span class="std std-ref">enabled at compile time</span></a>.
This function checks if exceptions were enabled.</p>
<p>When using the library interface with C++ exceptions enabled, the library
interface functions will “catch” them, and the error status can then be
checked by calling <a class="reference internal" href="#f/_/has_error" title="f/_/has_error"><code class="xref f f-func docutils literal notranslate"><span class="pre">has_error()</span></code></a>. The most recent error message can be
retrieved via <a class="reference internal" href="#f/_/get_last_error_message" title="f/_/get_last_error_message"><code class="xref f f-func docutils literal notranslate"><span class="pre">get_last_error_message()</span></code></a>.
This can allow one to restart a calculation or delete and recreate
the LAMMPS instance when a C++ exception occurs.  One application
of using exceptions this way is the <a class="reference internal" href="Tools.html#lammps-shell"><span class="std std-ref">LAMMPS shell</span></a>.  If C++
exceptions are disabled and an error happens during a call to
LAMMPS or the Fortran API, the application will terminate.</p>
<dl class="field-list simple">
<dt class="field-odd">Call to<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="Library_config.html#_CPPv428lammps_config_has_exceptionsv" title="lammps_config_has_exceptions"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_config_has_exceptions()</span></code></a></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>has_exceptions</strong><em> [</em><em>logical</em><em>]</em></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/config_has_package">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">config_has_package</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/config_has_package" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether a specific package has been included in LAMMPS</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>This function checks whether the LAMMPS library in use includes the specific
<a class="reference internal" href="Packages.html"><span class="doc">LAMMPS package</span></a> provided as argument.</p>
<dl class="field-list simple">
<dt class="field-odd">Call to<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="Library_config.html#_CPPv425lammps_config_has_packagePKc" title="lammps_config_has_package"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_config_has_package()</span></code></a></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>has_package</strong><em> [</em><em>logical</em><em>]</em></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/config_package_count">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">config_package_count</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#f/_/config_package_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of installed packages in the LAMMPS library.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>This function counts how many <a class="reference internal" href="Packages.html"><span class="doc">LAMMPS packages</span></a> are
included in the LAMMPS library in use. It directly calls the C library
function <a class="reference internal" href="Library_config.html#_CPPv427lammps_config_package_countv" title="lammps_config_package_count"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_config_package_count()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Call to<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="Library_config.html#_CPPv427lammps_config_package_countv" title="lammps_config_package_count"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_config_package_count()</span></code></a></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>npackages</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: number of packages installed</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/config_package_name">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">config_package_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">idx</span></em>, <em class="sig-param"><span class="pre">buffer</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/config_package_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the name of a package in the list of installed packages in the LAMMPS
library.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>This subroutine copies the name of the package with the index <em>idx</em> into the
provided string <em>buffer</em>. If the name of the package exceeds the length of
the buffer, it will be truncated accordingly.  If the index is out of range,
<em>buffer</em> is set to an empty string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>idx</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: index of the package in the list of included packages
<span class="math notranslate nohighlight">\((0 \le idx &lt; \text{package count})\)</span></p></li>
<li><p><strong>buffer</strong><em> [</em><em>character(len=*)</em><em>]</em> :: string to hold the name of the package</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_config.html#_CPPv426lammps_config_package_nameiPci" title="lammps_config_package_name"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_config_package_name()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/installed_packages">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">installed_packages</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">package</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">length</span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#f/_/installed_packages" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain a list of the names of enabled packages in the LAMMPS shared library
and store it in <em>package</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>This function is analogous to the <a class="reference internal" href="Python_module.html#lammps.lammps.installed_packages" title="lammps.lammps.installed_packages"><code class="xref py py-meth docutils literal notranslate"><span class="pre">installed_packages</span></code></a> function in the Python API.
The optional argument <em>length</em> sets the length of each string in the vector
<em>package</em> (default: 31).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>package</strong><em> [</em><em>character(len=:)</em><em>,</em><em>dimension(:),allocatable</em><em>]</em> :: list of packages;
<em>must</em> have the <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> attribute and be of rank 1
(i.e., <code class="docutils literal notranslate"><span class="pre">DIMENSION(:)</span></code>) with allocatable length.</p>
</dd>
<dt class="field-even">Options<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>length</strong><em> [</em><em>integer,optional</em><em>]</em> :: length of each string in the list. Default: 31.</p>
</dd>
<dt class="field-odd">Call to<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="Library_config.html#_CPPv427lammps_config_package_countv" title="lammps_config_package_count"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_config_package_count()</span></code></a> <a class="reference internal" href="Library_config.html#_CPPv426lammps_config_package_nameiPci" title="lammps_config_package_name"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_config_package_name()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/config_accelerator">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">config_accelerator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">package</span></em>, <em class="sig-param"><span class="pre">category</span></em>, <em class="sig-param"><span class="pre">setting</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/config_accelerator" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls <a class="reference internal" href="Library_config.html#_CPPv425lammps_config_acceleratorPKcPKcPKc" title="lammps_config_accelerator"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_config_accelerator()</span></code></a> to check the
availability of compile time settings of included
<a class="reference internal" href="Speed_packages.html"><span class="doc">accelerator packages</span></a> in LAMMPS.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>Supported packages names are “GPU”, “KOKKOS”, “INTEL”, and “OPENMP”.
Supported categories are “api” with possible settings “cuda”, “hip”, “phi”,
“pthreads”, “opencl”, “openmp”, and “serial”; and “precision” with
possible settings “double”, “mixed”, and “single”.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>package</strong><em> [</em><em>character(len=*)</em><em>]</em> :: string with the name of the accelerator
package</p></li>
<li><p><strong>category</strong><em> [</em><em>character(len=*)</em><em>]</em> :: string with the name of the setting</p></li>
<li><p><strong>setting</strong><em> [</em><em>character(len=*)</em><em>]</em> :: string with the name of the specific
setting</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_config.html#_CPPv425lammps_config_acceleratorPKcPKcPKc" title="lammps_config_accelerator"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_config_accelerator()</span></code></a></p>
</dd>
<dt class="field-odd">Return<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>available</strong><em> [</em><em>logical</em><em>]</em> :: <code class="docutils literal notranslate"><span class="pre">.TRUE.</span></code> if the combination of package, category,
and setting is available, otherwise <code class="docutils literal notranslate"><span class="pre">.FALSE.</span></code>.</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/has_gpu_device">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">has_gpu_device</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#f/_/has_gpu_device" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks for the presence of a viable GPU package device.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>This function calls <a class="reference internal" href="Library_config.html#_CPPv421lammps_has_gpu_devicev" title="lammps_has_gpu_device"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_has_gpu_device()</span></code></a>, which checks at
runtime whether an accelerator device is present that can be used with the
<a class="reference internal" href="Speed_gpu.html"><span class="doc">GPU package</span></a>.</p>
<p>More detailed information about the available device or devices can
be obtained by calling the
<a class="reference internal" href="#f/_/get_gpu_device_info" title="f/_/get_gpu_device_info"><code class="xref f f-subr docutils literal notranslate"><span class="pre">get_gpu_device_info()</span></code></a> subroutine.</p>
<dl class="field-list simple">
<dt class="field-odd">Call to<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="Library_config.html#_CPPv421lammps_has_gpu_devicev" title="lammps_has_gpu_device"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_has_gpu_device()</span></code></a></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>available</strong><em> [</em><em>logical</em><em>]</em> :: <code class="docutils literal notranslate"><span class="pre">.TRUE.</span></code> if a viable device is available, <code class="docutils literal notranslate"><span class="pre">.FALSE.</span></code> if not.</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/get_gpu_device_info">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">get_gpu_device_info</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">buffer</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/get_gpu_device_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Get GPU package device information.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>Calls <a class="reference internal" href="Library_config.html#_CPPv426lammps_get_gpu_device_infoPci" title="lammps_get_gpu_device_info"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_get_gpu_device_info()</span></code></a> to retrieve detailed
information about any accelerator devices that are viable for use with the
<a class="reference internal" href="Speed_gpu.html"><span class="doc">GPU package</span></a>. It will fill <em>buffer</em> with a string that is
equivalent to the output of the <code class="docutils literal notranslate"><span class="pre">nvc_get_device</span></code> or <code class="docutils literal notranslate"><span class="pre">ocl_get_device</span></code> or
<code class="docutils literal notranslate"><span class="pre">hip_get_device</span></code> tools that are compiled alongside LAMMPS if the GPU
package is enabled.</p>
<p>A suitable-length Fortran string has to be provided. The assembled text will
be truncated so as not to overflow this buffer.  This string can be several
kilobytes long if multiple devices are present.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>buffer</strong><em> [</em><em>character(len=*)</em><em>]</em> :: string into which to copy the information.</p>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_config.html#_CPPv426lammps_get_gpu_device_infoPci" title="lammps_get_gpu_device_info"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_get_gpu_device_info()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/has_style">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">has_style</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">category</span></em>, <em class="sig-param"><span class="pre">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/has_style" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether a specific style has been included in LAMMPS.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>This function calls <a class="reference internal" href="Library_config.html#_CPPv416lammps_has_stylePvPKcPKc" title="lammps_has_style"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_has_style()</span></code></a> to check whether the
LAMMPS library in use includes the specific style <em>name</em> associated with a
specific <em>category</em> provided as arguments.  Please see
<a class="reference internal" href="Library_config.html#_CPPv416lammps_has_stylePvPKcPKc" title="lammps_has_style"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_has_style()</span></code></a> for a list of valid categories.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>category</strong><em> [</em><em>character(len=*)</em><em>]</em> :: category of the style</p></li>
<li><p><strong>name</strong><em> [</em><em>character(len=*)</em><em>]</em> :: name of the style</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_config.html#_CPPv416lammps_has_stylePvPKcPKc" title="lammps_has_style"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_has_style()</span></code></a></p>
</dd>
<dt class="field-odd">Return<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>has_style</strong><em> [</em><em>logical</em><em>]</em> :: <code class="docutils literal notranslate"><span class="pre">.TRUE.</span></code> if included, <code class="docutils literal notranslate"><span class="pre">.FALSE.</span></code> if not.</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/style_count">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">style_count</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">category</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/style_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of styles of <em>category</em> in the LAMMPS library.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>This function counts how many styles in the provided <em>category</em> are
included in the LAMMPS library currently in use. Please see
<a class="reference internal" href="Library_config.html#_CPPv416lammps_has_stylePvPKcPKc" title="lammps_has_style"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_has_style()</span></code></a> for a list of valid categories.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>category</strong><em> [</em><em>character(len=*)</em><em>]</em> :: category of styles to count</p>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_config.html#_CPPv418lammps_style_countPvPKc" title="lammps_style_count"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_style_count()</span></code></a></p>
</dd>
<dt class="field-odd">Return<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>count</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: number of styles in <em>category</em></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/style_name">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">style_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">category</span></em>, <em class="sig-param"><span class="pre">idx</span></em>, <em class="sig-param"><span class="pre">buffer</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/style_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Look up the name of a style by index in the list of styles of a given
category in the LAMMPS library.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>This function calls <a class="reference internal" href="Library_config.html#_CPPv417lammps_style_namePvPKciPci" title="lammps_style_name"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_style_name()</span></code></a> and copies the name of
the <em>category</em> style with index <em>idx</em> into the provided string <em>buffer</em>.
The length of <em>buffer</em> must be long enough to contain the name of the
style; if it is too short, the name will be truncated accordingly.
If <em>idx</em> is out of range, <em>buffer</em> will be the empty string and a warning
will be issued.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>category</strong><em> [</em><em>character(len=*)</em><em>]</em> :: category of styles</p></li>
<li><p><strong>idx</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: index of the style in the list of <em>category</em>
styles <span class="math notranslate nohighlight">\((1 \leq idx \leq \text{style count})\)</span></p></li>
<li><p><strong>buffer</strong><em> [</em><em>character(len*)</em><em>]</em> :: string buffer to copy the name of the style
into</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_config.html#_CPPv417lammps_style_namePvPKciPci" title="lammps_style_name"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_style_name()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/has_id">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">has_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">category</span></em>, <em class="sig-param"><span class="pre">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/has_id" title="Permalink to this definition">¶</a></dt>
<dd><p>This function checks if the current LAMMPS instance a <em>category</em> ID of
the given <em>name</em> exists.  Valid categories are: <em>compute</em>, <em>dump</em>,
<em>fix</em>, <em>group</em>, <em>molecule</em>, <em>region</em>, and <em>variable</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>category</strong><em> [</em><em>character(len=*)</em><em>]</em> :: category of the ID</p></li>
<li><p><strong>name</strong><em> [</em><em>character(len=*)</em><em>]</em> :: name of the ID</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_config.html#_CPPv413lammps_has_idPvPKcPKc" title="lammps_has_id"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_has_id()</span></code></a></p>
</dd>
<dt class="field-odd">Return<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>has_id</strong><em> [</em><em>logical</em><em>]</em> :: <code class="docutils literal notranslate"><span class="pre">.TRUE.</span></code> if <em>category</em> style <em>name</em> exists, <code class="docutils literal notranslate"><span class="pre">.FALSE.</span></code> if not.</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/id_count">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">id_count</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">category</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/id_count" title="Permalink to this definition">¶</a></dt>
<dd><p>This function counts how many IDs in the provided <em>category</em> are defined in
the current LAMMPS instance. Please see <a class="reference internal" href="#f/_/has_id" title="f/_/has_id"><code class="xref f f-func docutils literal notranslate"><span class="pre">has_id()</span></code></a> for a list of
valid categories.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>category</strong><em> [</em><em>character(len=*)</em><em>]</em> :: category of the ID</p>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_config.html#_CPPv415lammps_id_countPvPKc" title="lammps_id_count"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_id_count()</span></code></a></p>
</dd>
<dt class="field-odd">Return<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>count</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: number of IDs in <em>category</em></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/id_name">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">id_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">category</span></em>, <em class="sig-param"><span class="pre">idx</span></em>, <em class="sig-param"><span class="pre">buffer</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/id_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Look up the name of an ID by index in the list of IDs of a given category.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>This function copies the name of the <em>category</em> ID with the index <em>idx</em> into
the provided string <em>buffer</em>.  The length of the buffer must be long
enough to hold the string; if the name of the style exceeds the length of
the buffer, it will be truncated accordingly. If <em>buffer</em> is
<code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code>, it must be allocated <em>before</em> the function is called.
If <em>idx</em> is out of range, <em>buffer</em> is set to an empty string and a warning
is issued.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>category</strong><em> [</em><em>character(len=*)</em><em>]</em> :: category of IDs</p></li>
<li><p><strong>idx</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: index of the ID in the list of <em>category</em>
styles (<span class="math notranslate nohighlight">\(0 \leq idx &lt; count\)</span>)</p></li>
<li><p><strong>buffer</strong><em> [</em><em>character(len=*)</em><em>]</em> :: string into which to copy the name of the
style</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_config.html#_CPPv414lammps_id_namePvPKciPci" title="lammps_id_name"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_id_name()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/plugin_count">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">plugin_count</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#f/_/plugin_count" title="Permalink to this definition">¶</a></dt>
<dd><p>This function counts the number of loaded plugins.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Call to<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_plugin_count()</span></code></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>n</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: number of loaded plugins</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/plugin_name">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">plugin_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">idx</span></em>, <em class="sig-param"><span class="pre">stylebuf</span></em>, <em class="sig-param"><span class="pre">namebuf</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/plugin_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Look up the style and name of a plugin by its index in the list of plugins.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>This function copies the name of the <em>style</em> plugin with the index <em>idx</em>
into the provided C-style string buffer.  The length of the buffer must be
provided as <em>buf_size</em> argument.  If the name of the style exceeds the
length of the buffer, it will be truncated accordingly.  If the index is out
of range, both strings are set to the empty string and a warning is
printed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>idx</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: index of the plugin in the list all or
<em>style</em> plugins</p></li>
<li><p><strong>stylebuf</strong><em> [</em><em>character(len=*)</em><em>]</em> :: string into which to copy the style of the
plugin</p></li>
<li><p><strong>namebuf</strong><em> [</em><em>character(len=*)</em><em>]</em> :: string into which to copy the style of the
plugin</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_plugin_name()</span></code></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/encode_image_flags">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">encode_image_flags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">ix</span></em>, <em class="sig-param"><span class="pre">iy</span></em>, <em class="sig-param"><span class="pre">iz</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/encode_image_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes three integer image flags into a single imageint.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>This function performs the bit-shift, addition, and bit-wise OR operations
necessary to combine the values of three integers representing the image
flags in the <span class="math notranslate nohighlight">\(x\)</span>-, <span class="math notranslate nohighlight">\(y\)</span>-, and <span class="math notranslate nohighlight">\(z\)</span>-directions. Unless LAMMPS
is compiled with <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code>, those integers are limited to 10-bit
signed integers <span class="math notranslate nohighlight">\([-512,512)\)</span>. If <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code> was used when
compiling, then the return value is of kind <code class="docutils literal notranslate"><span class="pre">c_int64_t</span></code> instead of
kind <code class="docutils literal notranslate"><span class="pre">c_int</span></code>, and the valid range for the individual image flags becomes
<span class="math notranslate nohighlight">\([-1048576,1048575)\)</span> (i.e., the range of a 21-bit signed integer).
There is no check on whether the arguments conform to these requirements;
values out of range will simply be wrapped back into the interval.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ix</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: image flag in <span class="math notranslate nohighlight">\(x\)</span>-direction</p></li>
<li><p><strong>iy</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: image flag in <span class="math notranslate nohighlight">\(y\)</span>-direction</p></li>
<li><p><strong>iz</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: image flag in <span class="math notranslate nohighlight">\(z\)</span>-direction</p></li>
</ul>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>imageint</strong><em> [</em><em>integer(kind=*)</em><em>]</em> :: encoded image flag. *The <code class="docutils literal notranslate"><span class="pre">KIND</span></code> parameter
is <code class="docutils literal notranslate"><span class="pre">c_int</span></code> unless LAMMPS was built with <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code>, in which
case it is <code class="docutils literal notranslate"><span class="pre">c_int64_t</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The fact that the programmer does not know the <code class="docutils literal notranslate"><span class="pre">KIND</span></code> parameter of the
return value until compile time means that it is impossible to define an
interface that works for both sizes of <code class="docutils literal notranslate"><span class="pre">imageint</span></code>. One side effect of
this is that you must assign the return value of this function to a
variable; it cannot be used as the argument to another function or as part
of an array constructor. For example,</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="n">my_images</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">lmp</span><span class="p">%</span><span class="n">encode_image_flags</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">encode_image_flags</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
</pre></div>
</div>
<p>will <em>not</em> work; instead, do something like</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="n">my_images</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">encode_image_flags</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">my_images</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lmp</span><span class="p">%</span><span class="n">encode_image_flags</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/decode_image_flags">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">decode_image_flags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">image</span></em>, <em class="sig-param"><span class="pre">flags</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/decode_image_flags" title="Permalink to this definition">¶</a></dt>
<dd><p>This function does the reverse operation of <a class="reference internal" href="#f/_/encode_image_flags" title="f/_/encode_image_flags"><code class="xref f f-func docutils literal notranslate"><span class="pre">encode_image_flags()</span></code></a>:
it takes the image flag and performs the bit-shift and bit-masking
operations to decode it and stores the resulting three integers into the
array <em>flags</em>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong><em> [</em><em>integer(kind=*)</em><em>]</em> :: encoded image flag. *The <code class="docutils literal notranslate"><span class="pre">KIND</span></code> parameter is
either <code class="docutils literal notranslate"><span class="pre">c_int</span></code> or, if LAMMPS was compiled with <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code>,
<code class="docutils literal notranslate"><span class="pre">c_int64_t</span></code>. Kind compatibility is checked at run-time.</p></li>
<li><p><strong>flags</strong><em> [</em><em>integer(c_int)</em><em>,</em><em>dimension(3)</em><em>]</em> :: three-element vector where the
decoded image flags will be stored.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/set_fix_external_callback">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">set_fix_external_callback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">id</span></em>, <em class="sig-param"><span class="pre">callback</span></em>, <em class="sig-param"><span class="pre">caller</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/set_fix_external_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the callback function for a <a class="reference internal" href="fix_external.html"><span class="doc">fix external</span></a> instance
with the given ID.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 22Dec2022.</span></p>
</div>
<p>Fix <a class="reference internal" href="fix_external.html"><span class="doc">external</span></a> allows programs that are running LAMMPS
through its library interface to modify certain LAMMPS properties on
specific time steps, similar to the way other fixes do.</p>
<p>This subroutine sets the callback function for use with the “pf/callback”
mode. The function should have Fortran language bindings with the following
interface, which depends on how LAMMPS was compiled:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">ABSTRACT INTERFACE</span>
<span class="k">  SUBROUTINE </span><span class="n">external_callback</span><span class="p">(</span><span class="n">caller</span><span class="p">,</span><span class="w"> </span><span class="n">timestep</span><span class="p">,</span><span class="w"> </span><span class="n">ids</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">fexternal</span><span class="p">)</span>
<span class="w">    </span><span class="k">USE</span><span class="p">,</span><span class="w"> </span><span class="k">INTRINSIC</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="nb">ISO_C_BINDING</span><span class="p">,</span><span class="w"> </span><span class="k">ONLY</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">c_int</span><span class="p">,</span><span class="w"> </span><span class="kt">c_double</span><span class="p">,</span><span class="w"> </span><span class="kt">c_int64_t</span>
<span class="kt">    </span><span class="k">CLASS</span><span class="p">(</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="k">INTENT</span><span class="p">(</span><span class="n">INOUT</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">caller</span>
<span class="w">    </span><span class="kt">INTEGER</span><span class="p">(</span><span class="n">c_bigint</span><span class="p">),</span><span class="w"> </span><span class="k">INTENT</span><span class="p">(</span><span class="n">IN</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">timestep</span>
<span class="w">    </span><span class="kt">INTEGER</span><span class="p">(</span><span class="n">c_tagint</span><span class="p">),</span><span class="w"> </span><span class="k">DIMENSION</span><span class="p">(:),</span><span class="w"> </span><span class="k">INTENT</span><span class="p">(</span><span class="n">IN</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">ids</span>
<span class="w">    </span><span class="kt">REAL</span><span class="p">(</span><span class="kt">c_double</span><span class="p">),</span><span class="w"> </span><span class="k">DIMENSION</span><span class="p">(:,:),</span><span class="w"> </span><span class="k">INTENT</span><span class="p">(</span><span class="n">IN</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span>
<span class="w">    </span><span class="kt">REAL</span><span class="p">(</span><span class="kt">c_double</span><span class="p">),</span><span class="w"> </span><span class="k">DIMENSION</span><span class="p">(:,:),</span><span class="w"> </span><span class="k">INTENT</span><span class="p">(</span><span class="n">OUT</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">fexternal</span>
<span class="w">  </span><span class="k">END SUBROUTINE </span><span class="n">external_callback</span>
<span class="k">END INTERFACE</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">c_bigint</span></code> is <code class="docutils literal notranslate"><span class="pre">c_int</span></code> if <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_SMALLSMALL</span></code> was used and
<code class="docutils literal notranslate"><span class="pre">c_int64_t</span></code> otherwise; and <code class="docutils literal notranslate"><span class="pre">c_tagint</span></code> is <code class="docutils literal notranslate"><span class="pre">c_int64_t</span></code> if
<code class="docutils literal notranslate"><span class="pre">-DLAMMPS_BIGBIG</span></code> was used and <code class="docutils literal notranslate"><span class="pre">c_int</span></code> otherwise.</p>
<p>The argument <em>caller</em> to <a class="reference internal" href="#f/_/set_fix_external_callback" title="f/_/set_fix_external_callback"><code class="xref f f-subr docutils literal notranslate"><span class="pre">set_fix_external_callback()</span></code></a> is unlimited
polymorphic (i.e., it can be any Fortran object you want to pass to the
calling function) and will be available as the first argument to the
callback function. It can be your LAMMPS instance, which you might need if
the callback function needs access to the library interface.
The argument must be a scalar; to pass non-scalar data, wrap those data in
a derived type and pass an instance of the derived type to <em>caller</em>.</p>
<p>The array <em>ids</em> is an array of length <em>nlocal</em> (as accessed from the
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Atom</span></code> class or through <a class="reference internal" href="#f/_/extract_global" title="f/_/extract_global"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_global()</span></code></a>). The arrays
<em>x</em> and <em>fexternal</em> are <span class="math notranslate nohighlight">\(3 \times {}\)</span><em>nlocal</em> arrays; these are
transposed from what they would look like in C (see note about array index
order at <a class="reference internal" href="#f/_/extract_atom" title="f/_/extract_atom"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_atom()</span></code></a>).</p>
<p>The callback mechanism is one of two ways that forces can be applied to a
simulation with the help of <a class="reference internal" href="fix_external.html"><span class="doc">fix external</span></a>. The
alternative is <em>array</em> mode, where one calls
<a class="reference internal" href="#f/_/fix_external_get_force" title="f/_/fix_external_get_force"><code class="xref f f-func docutils literal notranslate"><span class="pre">fix_external_get_force()</span></code></a>.</p>
<p>Please see the documentation for <a class="reference internal" href="fix_external.html"><span class="doc">fix external</span></a> for
more information about how to use the fix and couple it with external
programs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>id</strong><em> [</em><em>character(len=*)</em><em>]</em> :: ID of <a class="reference internal" href="fix_external.html"><span class="doc">fix external</span></a> instance</p></li>
<li><p><strong>callback</strong><em> [</em><em>external</em><em>]</em> :: subroutine <a class="reference internal" href="fix_external.html"><span class="doc">fix external</span></a> should call</p></li>
<li><p><strong>caller</strong><em> [</em><em>class(*)</em><em>,</em><em>optional</em><em>]</em> :: object you wish to pass to the callback
procedure (must be a scalar; see note)</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_utility.html#_CPPv432lammps_set_fix_external_callbackPvPKc16FixExternalFnPtrPv" title="lammps_set_fix_external_callback"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_set_fix_external_callback()</span></code></a></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The interface for your callback function must match types precisely
with the abstract interface block given above. <strong>The compiler probably
will not be able to check this for you.</strong> In particular, the first
argument (“caller”) must be of type <code class="docutils literal notranslate"><span class="pre">CLASS(*)</span></code> or you will probably
get a segmentation fault or at least a misinterpretation of whatever is
in memory there. You can resolve the object using the <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">TYPE</span></code>
construct. An example callback function (assuming LAMMPS was compiled
with <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_SMALLBIG</span></code>) that applies something akin to Hooke’s Law
(with each atom having a different <em>k</em> value) is shown below.</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="k">MODULE </span><span class="n">stuff</span>
<span class="w">  </span><span class="k">USE</span><span class="p">,</span><span class="w"> </span><span class="k">INTRINSIC</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="nb">ISO_C_BINDING</span><span class="p">,</span><span class="w"> </span><span class="k">ONLY</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">c_int</span><span class="p">,</span><span class="w"> </span><span class="kt">c_double</span><span class="p">,</span><span class="w"> </span><span class="kt">c_int64_t</span>
<span class="kt">  </span><span class="k">USE</span><span class="p">,</span><span class="w"> </span><span class="k">INTRINSIC</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">ISO_FORTRAN_ENV</span><span class="p">,</span><span class="w"> </span><span class="k">ONLY</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">error_unit</span>
<span class="w">  </span><span class="k">IMPLICIT NONE</span>

<span class="k">  TYPE </span><span class="n">shield</span>
<span class="w">     </span><span class="kt">REAL</span><span class="p">(</span><span class="kt">c_double</span><span class="p">),</span><span class="w"> </span><span class="k">DIMENSION</span><span class="p">(:,:),</span><span class="w"> </span><span class="k">ALLOCATABLE</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">k</span>
<span class="w">     </span><span class="c">! assume k gets allocated to dimension(3,nlocal) at some point</span>
<span class="w">     </span><span class="c">! and assigned values</span>
<span class="w">  </span><span class="k">END TYPE </span><span class="n">shield</span>

<span class="w">  </span><span class="k">SUBROUTINE </span><span class="n">my_callback</span><span class="p">(</span><span class="n">caller</span><span class="p">,</span><span class="w"> </span><span class="n">timestep</span><span class="p">,</span><span class="w"> </span><span class="n">ids</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">fexternal</span><span class="p">)</span>
<span class="w">    </span><span class="k">CLASS</span><span class="p">(</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="k">INTENT</span><span class="p">(</span><span class="n">INOUT</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">caller</span>
<span class="w">    </span><span class="kt">INTEGER</span><span class="p">(</span><span class="kt">c_int</span><span class="p">),</span><span class="w"> </span><span class="k">INTENT</span><span class="p">(</span><span class="n">IN</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">timestep</span>
<span class="w">    </span><span class="kt">INTEGER</span><span class="p">(</span><span class="kt">c_int64_t</span><span class="p">),</span><span class="w"> </span><span class="k">INTENT</span><span class="p">(</span><span class="n">IN</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">ids</span>
<span class="w">    </span><span class="kt">REAL</span><span class="p">(</span><span class="kt">c_double</span><span class="p">),</span><span class="w"> </span><span class="k">INTENT</span><span class="p">(</span><span class="n">IN</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">x</span><span class="p">(:,:)</span>
<span class="w">    </span><span class="kt">REAL</span><span class="p">(</span><span class="kt">c_double</span><span class="p">),</span><span class="w"> </span><span class="k">INTENT</span><span class="p">(</span><span class="n">OUT</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">fexternal</span><span class="p">(:,:)</span>

<span class="w">    </span><span class="k">SELECT TYPE</span><span class="w"> </span><span class="p">(</span><span class="n">caller</span><span class="p">)</span>
<span class="w">      </span><span class="k">TYPE IS</span><span class="w"> </span><span class="p">(</span><span class="n">shield</span><span class="p">)</span>
<span class="w">         </span><span class="n">fexternal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">caller</span><span class="p">%</span><span class="n">k</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span>
<span class="w">      </span><span class="k">CLASS </span><span class="n">DEFAULT</span>
<span class="w">         </span><span class="k">WRITE</span><span class="p">(</span><span class="n">error_unit</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s1">&#39;UH OH...&#39;</span>
<span class="w">    </span><span class="k">END SELECT</span>
<span class="k">  END SUBROUTINE </span><span class="n">my_callback</span>
<span class="k">END MODULE </span><span class="n">stuff</span>

<span class="c">! then, when assigning the callback function, do this:</span>
<span class="k">PROGRAM </span><span class="n">example</span>
<span class="w">  </span><span class="k">USE </span><span class="n">LIBLAMMPS</span>
<span class="w">  </span><span class="k">USE </span><span class="n">stuff</span>
<span class="w">  </span><span class="k">TYPE</span><span class="p">(</span><span class="n">lammps</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">lmp</span>
<span class="w">  </span><span class="k">TYPE</span><span class="p">(</span><span class="n">shield</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">my_shield</span>
<span class="w">  </span><span class="n">lmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lammps</span><span class="p">()</span>
<span class="w">  </span><span class="k">CALL </span><span class="n">lmp</span><span class="p">%</span><span class="n">command</span><span class="p">(</span><span class="s1">&#39;fix ext all external pf/callback 1 1&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="k">CALL </span><span class="n">lmp</span><span class="p">%</span><span class="n">set_fix_external_callback</span><span class="p">(</span><span class="s1">&#39;ext&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">my_callback</span><span class="p">,</span><span class="w"> </span><span class="n">my_shield</span><span class="p">)</span>
<span class="k">END PROGRAM </span><span class="n">example</span>
</pre></div>
</div>
</div>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/fix_external_get_force">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">fix_external_get_force</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">id</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/fix_external_get_force" title="Permalink to this definition">¶</a></dt>
<dd><p>Get pointer to the force array storage in a fix external instance with the
given ID.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 22Dec2022.</span></p>
</div>
<p>Fix <a class="reference internal" href="fix_external.html"><span class="doc">external</span></a> allows programs that are running LAMMPS
through its library interfaces to add or modify certain LAMMPS properties on
specific time steps, similar to the way other fixes do.</p>
<p>This function provides access to the per-atom force storage in a fix
external instance with the given fix-ID to be added to the individual
atoms when using the “pf/array” mode.  The <em>fexternal</em> array can be
accessed like other “native” per-atom arrays accessible via the
<a class="reference internal" href="#f/_/extract_atom" title="f/_/extract_atom"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_atom()</span></code></a> function.  Please note that the array
stores the forces for <em>local</em> atoms for each MPI rank, in the order
determined by the neighbor list build.  Because the underlying data
structures can change as well as the order of atom as they migrate between
MPI processes because of the domain decomposition parallelization, this
function should be always called immediately before the forces are going to
be set to get an up-to-date pointer.  You can use, for example,
<a class="reference internal" href="#f/_/extract_setting" title="f/_/extract_setting"><code class="xref f f-func docutils literal notranslate"><span class="pre">extract_setting()</span></code></a> to obtain the number of local atoms <cite>nlocal</cite> and
then assume the dimensions of the returned force array as
<code class="docutils literal notranslate"><span class="pre">REAL(c_double)</span> <span class="pre">::</span> <span class="pre">force(3,nlocal)</span></code>.</p>
<p>This function is an alternative to the callback mechanism in fix external
set up by <a class="reference internal" href="#f/_/set_fix_external_callback" title="f/_/set_fix_external_callback"><code class="xref f f-subr docutils literal notranslate"><span class="pre">set_fix_external_callback()</span></code></a>. The main difference is that
this mechanism can be used when forces are to be pre-computed and the
control alternates between LAMMPS and the external driver, while the
callback mechanism can call an external subroutine to compute the force when
the fix is triggered and needs them.</p>
<p>Please see the documentation for <a class="reference internal" href="fix_external.html"><span class="doc">fix external</span></a> for
more information about how to use the fix and how to couple it with an
external program.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>id</strong><em> [</em><em>character(len=*)</em><em>]</em> :: ID of <a class="reference internal" href="fix_external.html"><span class="doc">fix external</span></a> instance</p>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_utility.html#_CPPv429lammps_fix_external_get_forcePvPKc" title="lammps_fix_external_get_force"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_fix_external_get_force()</span></code></a></p>
</dd>
<dt class="field-odd">Return<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>fexternal</strong><em> [</em><em>real(c_double),dimension(3,nlocal)</em><em>]</em> :: pointer to the per-atom force array allocated by the fix</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/fix_external_set_energy_global">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">fix_external_set_energy_global</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">id</span></em>, <em class="sig-param"><span class="pre">eng</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/fix_external_set_energy_global" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the global energy contribution for a <a class="reference internal" href="fix_external.html"><span class="doc">fix external</span></a>
instance with the given ID.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 22Dec2022.</span></p>
</div>
<p>This is a companion function to <a class="reference internal" href="#f/_/set_fix_external_callback" title="f/_/set_fix_external_callback"><code class="xref f f-func docutils literal notranslate"><span class="pre">set_fix_external_callback()</span></code></a>
and <a class="reference internal" href="#f/_/fix_external_get_force" title="f/_/fix_external_get_force"><code class="xref f f-func docutils literal notranslate"><span class="pre">fix_external_get_force()</span></code></a> that also sets the contribution to the
global energy from the external program.  The value of the <em>eng</em> argument
will be stored in the fix and applied on the current and all following
time steps until changed by another call to this function. The energy is in
energy units as determined by the current <a class="reference internal" href="units.html"><span class="doc">units</span></a> settings and
is the <strong>total</strong> energy of the contribution.  Thus, when running in
parallel, all MPI processes have to call this function with the <strong>same</strong>
value, and this will be returned as a scalar property of the fix external
instance when accessed in LAMMPS input commands or from variables.</p>
<p>Please see the documentation for <a class="reference internal" href="fix_external.html"><span class="doc">fix external</span></a> for more
information about how to use the fix and how to couple it with an external
program.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>id</strong><em> [</em><em>character(len=*)</em><em>]</em> :: fix ID of fix external instance</p></li>
<li><p><strong>eng</strong><em> [</em><em>real(c_double)</em><em>]</em> :: total energy to be added to the global energy</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_utility.html#_CPPv437lammps_fix_external_set_energy_globalPvPKcd" title="lammps_fix_external_set_energy_global"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_fix_external_set_energy_global()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/fix_external_set_virial_global">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">fix_external_set_virial_global</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">id</span></em>, <em class="sig-param"><span class="pre">virial</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/fix_external_set_virial_global" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the global virial contribution for a fix external instance with the
given ID.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 22Dec2022.</span></p>
</div>
<p>This is a companion function to <a class="reference internal" href="#f/_/set_fix_external_callback" title="f/_/set_fix_external_callback"><code class="xref f f-subr docutils literal notranslate"><span class="pre">set_fix_external_callback()</span></code></a>
and <a class="reference internal" href="#f/_/fix_external_get_force" title="f/_/fix_external_get_force"><code class="xref f f-func docutils literal notranslate"><span class="pre">fix_external_get_force()</span></code></a> to set the contribution to the global
virial from an external program.</p>
<p>The six values of the <em>virial</em> array will be stored in the fix and applied
on the current and all following time steps until changed by another call
to this function. The components of the virial need to be stored in the
following order: <em>xx</em>, <em>yy</em>, <em>zz</em>, <em>xy</em>, <em>xz</em>, <em>yz</em>.  In LAMMPS, the virial
is stored internally as <cite>stress*volume</cite> in units of <cite>pressure*volume</cite> as
determined by the current <a class="reference internal" href="units.html"><span class="doc">units</span></a> settings and is the
<strong>total</strong> contribution.  Thus, when running in parallel, all MPI processes
have to call this function with the <strong>same</strong> value, and this will then be
added by fix external.</p>
<p>Please see the documentation for <a class="reference internal" href="fix_external.html"><span class="doc">fix external</span></a> for
more information about how to use the fix and how to couple it with an
external code.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>id</strong><em> [</em><em>character(len=*)</em><em>]</em> :: fix ID of fix external instance</p></li>
<li><p><strong>virial</strong><em> [</em><em>real(c_double)</em><em>,</em><em>dimension(6)</em><em>]</em> :: the six global stress tensor
components to be added to the global virial</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_utility.html#_CPPv437lammps_fix_external_set_virial_globalPvPKcPd" title="lammps_fix_external_set_virial_global"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_fix_external_set_virial_global()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/fix_external_set_energy_peratom">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">fix_external_set_energy_peratom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">id</span></em>, <em class="sig-param"><span class="pre">eng</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/fix_external_set_energy_peratom" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the per-atom energy contribution for a fix external instance with the
given ID.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 22Dec2022.</span></p>
</div>
<p>This is a companion function to <a class="reference internal" href="#f/_/set_fix_external_callback" title="f/_/set_fix_external_callback"><code class="xref f f-subr docutils literal notranslate"><span class="pre">set_fix_external_callback()</span></code></a> to set
the per-atom energy contribution due to the fix from the external program as
part of the callback function.  For this to work, the LAMMPS object must be
passed as part of the <em>caller</em> argument when registering the callback
function, or the callback function must otherwise have access to the
LAMMPS object, such as through a module-based pointer.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is fully independent from
<a class="reference internal" href="#f/_/fix_external_set_energy_global" title="f/_/fix_external_set_energy_global"><code class="xref f f-subr docutils literal notranslate"><span class="pre">fix_external_set_energy_global()</span></code></a> and will <strong>NOT</strong> add any
contributions to the global energy tally and will <strong>NOT</strong> check whether
the sum of the contributions added here are consistent with the global
added energy.</p>
</div>
<p>Please see the documentation for <a class="reference internal" href="fix_external.html"><span class="doc">fix external</span></a> for
more information about how to use the fix and how to couple it with an
external code.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>id</strong><em> [</em><em>character(len=*)</em><em>]</em> :: fix ID of the fix external instance</p></li>
<li><p><strong>eng</strong><em> [</em><em>real(c_double)</em><em>,</em><em>dimension(:)</em><em>]</em> :: array of length <em>nlocal</em> containing
the energy to add to the per-atom energy</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_utility.html#_CPPv438lammps_fix_external_set_energy_peratomPvPKcPd" title="lammps_fix_external_set_energy_peratom"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_fix_external_set_energy_peratom()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/set_fix_external_set_virial_peratom">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">set_fix_external_set_virial_peratom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">id</span></em>, <em class="sig-param"><span class="pre">virial</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/set_fix_external_set_virial_peratom" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a companion function to <a class="reference internal" href="#f/_/set_fix_external_callback" title="f/_/set_fix_external_callback"><code class="xref f f-subr docutils literal notranslate"><span class="pre">set_fix_external_callback()</span></code></a> to set
the per-atom virial contribution due to the fix from the external program as
part of the callback function.  For this to work, the LAMMPS object must be
passed as the <em>caller</em> argument when registering the callback function.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 22Dec2022.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is fully independent from
<a class="reference internal" href="#f/_/fix_external_set_virial_global" title="f/_/fix_external_set_virial_global"><code class="xref f f-subr docutils literal notranslate"><span class="pre">fix_external_set_virial_global()</span></code></a> and will <strong>NOT</strong> add any
contributions to the global virial tally and <strong>NOT</strong> check whether the
sum of the contributions added here are consistent with the global added
virial.</p>
</div>
<p>The order and units of the per-atom stress tensor elements are the same
as for the global virial.  The type and dimensions of the per-atom virial
array must be <code class="docutils literal notranslate"><span class="pre">REAL(c_double),</span> <span class="pre">DIMENSION(6,nlocal)</span></code>.</p>
<p>Please see the documentation for <a class="reference internal" href="fix_external.html"><span class="doc">fix external</span></a> for
more information about how to use the fix and how to couple it with an
external program.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>id</strong><em> [</em><em>character(len=*)</em><em>]</em> :: fix ID of fix external instance</p></li>
<li><p><strong>virial</strong><em> [</em><em>real(c_double)</em><em>,</em><em>dimension(:,:)</em><em>]</em> :: an array of <span class="math notranslate nohighlight">\(6 \times{}\)</span><em>nlocal</em> components to be added to the per-atom virial</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_set_virial_peratom()</span></code></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/fix_external_set_vector_length">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">fix_external_set_vector_length</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">id</span></em>, <em class="sig-param"><span class="pre">length</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/fix_external_set_vector_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the vector length for a global vector stored with fix external for
analysis.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 22Dec2022.</span></p>
</div>
<p>This is a companion function to <a class="reference internal" href="#f/_/set_fix_external_callback" title="f/_/set_fix_external_callback"><code class="xref f f-subr docutils literal notranslate"><span class="pre">set_fix_external_callback()</span></code></a> and
<a class="reference internal" href="#f/_/fix_external_get_force" title="f/_/fix_external_get_force"><code class="xref f f-func docutils literal notranslate"><span class="pre">fix_external_get_force()</span></code></a> to set the length of a global vector of
properties that will be stored with the fix via
<a class="reference internal" href="#f/_/fix_external_set_vector" title="f/_/fix_external_set_vector"><code class="xref f f-subr docutils literal notranslate"><span class="pre">fix_external_set_vector()</span></code></a>.</p>
<p>This function needs to be called <strong>before</strong> a call to
<a class="reference internal" href="#f/_/fix_external_set_vector" title="f/_/fix_external_set_vector"><code class="xref f f-subr docutils literal notranslate"><span class="pre">fix_external_set_vector()</span></code></a> and <strong>before</strong> a run or minimize command.
When running in parallel, it must be called from <strong>all</strong> MPI
processes with the same length argument.</p>
<p>Please see the documentation for <a class="reference internal" href="fix_external.html"><span class="doc">fix external</span></a> for
more information about how to use the fix and how to couple it with an
external program.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>id</strong><em> [</em><em>character(len=*)</em><em>]</em> :: fix ID of fix external instance</p></li>
<li><p><strong>length</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: length of the global vector to be stored with the
fix</p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_utility.html#_CPPv437lammps_fix_external_set_vector_lengthPvPKci" title="lammps_fix_external_set_vector_length"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_fix_external_set_vector_length()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/fix_external_set_vector">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">fix_external_set_vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">id</span></em>, <em class="sig-param"><span class="pre">idx</span></em>, <em class="sig-param"><span class="pre">val</span></em><span class="sig-paren">)</span><a class="headerlink" href="#f/_/fix_external_set_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Store a global vector value for a fix external instance with the given ID.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 22Dec2022.</span></p>
</div>
<p>This is a companion function to <a class="reference internal" href="#f/_/set_fix_external_callback" title="f/_/set_fix_external_callback"><code class="xref f f-subr docutils literal notranslate"><span class="pre">set_fix_external_callback()</span></code></a> and
<a class="reference internal" href="#f/_/fix_external_get_force" title="f/_/fix_external_get_force"><code class="xref f f-func docutils literal notranslate"><span class="pre">fix_external_get_force()</span></code></a> to set the values of a global vector of
properties that will be stored with the fix and can be accessed from
within LAMMPS input commands (e.g., fix ave/time or variables) when used
in a vector context.</p>
<p>This function needs to be called <strong>after</strong> a call to
<a class="reference internal" href="#f/_/fix_external_set_vector_length" title="f/_/fix_external_set_vector_length"><code class="xref f f-subr docutils literal notranslate"><span class="pre">fix_external_set_vector_length()</span></code></a> and <strong>before</strong> a run or minimize
command.  When running in parallel, it must be called from <strong>all</strong> MPI
processes with the <strong>same</strong> <em>idx</em> and <em>val</em> parameters.  The variable
<em>val</em> is assumed to be extensive.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The index in the <em>idx</em> parameter is 1-based (i.e., the first element
is set with <em>idx</em><span class="math notranslate nohighlight">\({} = 1\)</span>, and the last element of the vector
with <em>idx</em><span class="math notranslate nohighlight">\({} = N\)</span>, where <span class="math notranslate nohighlight">\(N\)</span> is the value of the <em>length</em>
parameter of the call to <a class="reference internal" href="#f/_/fix_external_set_vector_length" title="f/_/fix_external_set_vector_length"><code class="xref f f-subr docutils literal notranslate"><span class="pre">fix_external_set_vector_length()</span></code></a>).</p>
</div>
<p>Please see the documentation for <a class="reference internal" href="fix_external.html"><span class="doc">fix external</span></a> for
more information about how to use the fix and how to couple it with an
external code.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>id</strong><em> [</em><em>character(len=*)</em><em>]</em> :: ID of fix external instance</p></li>
<li><p><strong>idx</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: 1-based index in global vector</p></li>
<li><p><strong>val</strong><em> [</em><em>integer(c_int)</em><em>]</em> :: value to be stored in global vector at index <em>idx</em></p></li>
</ul>
</dd>
<dt class="field-even">Call to<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="Library_utility.html#_CPPv430lammps_fix_external_set_vectorPvPKcid" title="lammps_fix_external_set_vector"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_fix_external_set_vector()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/flush_buffers">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">flush_buffers</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#f/_/flush_buffers" title="Permalink to this definition">¶</a></dt>
<dd><p>This function calls <a class="reference internal" href="Library_utility.html#_CPPv420lammps_flush_buffersPv" title="lammps_flush_buffers"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_flush_buffers()</span></code></a>, which flushes buffered
output to be written to screen and logfile. This can simplify capturing
output from LAMMPS library calls.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Call to<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="Library_utility.html#_CPPv420lammps_flush_buffersPv" title="lammps_flush_buffers"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_flush_buffers()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/is_running">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">is_running</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#f/_/is_running" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if LAMMPS is currently inside a run or minimization.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>This function can be used from signal handlers or multi-threaded
applications to determine if the LAMMPS instance is currently active.</p>
<dl class="field-list simple">
<dt class="field-odd">Call to<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="Library_utility.html#_CPPv417lammps_is_runningPv" title="lammps_is_running"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_is_running()</span></code></a></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>is_running</strong><em> [</em><em>logical</em><em>]</em> :: <code class="docutils literal notranslate"><span class="pre">.FALSE.</span></code> if idle or <code class="docutils literal notranslate"><span class="pre">.TRUE.</span></code> if active</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/force_timeout">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">force_timeout</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#f/_/force_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Force a timeout to stop an ongoing run cleanly.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>This function can be used from signal handlers or multi-threaded
applications to terminate an ongoing run cleanly.</p>
<dl class="field-list simple">
<dt class="field-odd">Call to<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="Library_utility.html#_CPPv420lammps_force_timeoutPv" title="lammps_force_timeout"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_force_timeout()</span></code></a></p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/has_error">
<em class="property"><span class="pre">function</span>&#160; </em><span class="sig-name descname"><span class="pre">has_error</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#f/_/has_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if there is a (new) error message available.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>This function can be used to query if an error inside of LAMMPS
has thrown a <a class="reference internal" href="Build_settings.html#exceptions"><span class="std std-ref">C++ exception</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will always report “no error” when the LAMMPS library
has been compiled without <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_EXCEPTIONS</span></code>, which turns fatal
errors aborting LAMMPS into C++ exceptions. You can use the library
function <a class="reference internal" href="Library_config.html#_CPPv428lammps_config_has_exceptionsv" title="lammps_config_has_exceptions"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_config_has_exceptions()</span></code></a> to check if this is
the case.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Call to<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="Library_utility.html#_CPPv416lammps_has_errorPv" title="lammps_has_error"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_has_error()</span></code></a></p>
</dd>
<dt class="field-even">Return<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>has_error</strong><em> [</em><em>logical</em><em>]</em> :: <code class="docutils literal notranslate"><span class="pre">.TRUE.</span></code> if there is an error.</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl>
<dt class="sig sig-object f" id="f/_/get_last_error_message">
<em class="property"><span class="pre">subroutine</span>&#160; </em><span class="sig-name descname"><span class="pre">get_last_error_message</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">buffer</span></em><span class="optional">[</span>, <em class="sig-param"><span class="pre">status</span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#f/_/get_last_error_message" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the last error message into the provided buffer.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 3Nov2022.</span></p>
</div>
<p>This function can be used to retrieve the error message that was set
in the event of an error inside of LAMMPS that resulted in a
<a class="reference internal" href="Build_settings.html#exceptions"><span class="std std-ref">C++ exception</span></a>.  A suitable buffer for a string has
to be provided.  If the internally-stored error message is longer than the
string, it will be truncated accordingly.  The optional argument <em>status</em>
indicates the kind of error: a “1” indicates an error that occurred on all
MPI ranks and is often recoverable, while a “2” indicates an abort that
would happen only in a single MPI rank and thus may not be recoverable, as
other MPI ranks may be waiting on the failing MPI rank(s) to send messages.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will do nothing when the LAMMPS library has been
compiled without <code class="docutils literal notranslate"><span class="pre">-DLAMMPS_EXCEPTIONS</span></code>, which turns errors aborting
LAMMPS into C++ exceptions.  You can use the function
<a class="reference internal" href="#f/_/config_has_exceptions" title="f/_/config_has_exceptions"><code class="xref f f-func docutils literal notranslate"><span class="pre">config_has_exceptions()</span></code></a> to check whether this is the case.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>buffer</strong><em> [</em><em>character(len=*)</em><em>]</em> :: string buffer to copy the error message into</p>
</dd>
<dt class="field-even">Options<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>status</strong><em> [</em><em>integer(c_int)</em><em>,</em><em>optional</em><em>]</em> :: 1 when all ranks had the error,
2 on a single-rank error.</p>
</dd>
<dt class="field-odd">Call to<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="Library_utility.html#_CPPv429lammps_get_last_error_messagePvPci" title="lammps_get_last_error_message"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lammps_get_last_error_message()</span></code></a></p>
</dd>
</dl>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Library_add.html" class="btn btn-neutral float-left" title="1.1.10. Extending the C API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="Cplusplus.html" class="btn btn-neutral float-right" title="1.4.1. Using the C++ API directly" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2003-2023 Sandia Corporation.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>

        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>